#+TITLE: Bus Charging Schedule Simulated Annealing with MILP Constraints
#+DATE: \today
#+EMAIL: A01704744@usu.edu
#+LANGUAGE: en

# Document options
#+OPTIONS: tex:t

# LaTex Configuration
#+LATEX_CLASS: article

#+latex_header: \newcommand{\T}{\mathcal{T}}
#+latex_header: \newcommand{\Tau}{T}
#+latex_header: \usepackage{lipsum}
#+latex_header: \usepackage{amsfonts}

# * Abstract
# #+begin_export latex
# \begin{abstract}
# \lipsum[1-2]
# \end{abstract}
# #+end_export

* Introduction
This document outlines the simulated annealing (SA) approach to the bus charging scheduling problem utilizing Mixed
Integer Linear Programming (MILP) constraints as the method of determining feasible charging schedules. The problem
statement is as follows: given a set of routes for a fleet of Battery Electric Buses (BEB), generate an optimal charging
schedule to minimize the consumption cost (amount of electricity used over a certain time) and the demand cost (rate at
which electricity is being used) within the constraints that the buses must maintain sufficient charge to complete the working
day and do not have any delays in their respective routes.

Simulated Annealing (SA) shall be introduced and utilized as a means of finding the global optimum. The SA algorithm
shall be constrained by a set of Mixed Integer Linear Program (MILP) constraints to ensure validity of the proposed
charging schedules. A set of objective functions describing consumption cost and demand cost, as stated above, shall be
minimized as to reduce power consumption and total cost of using the BEBs.

* Problem Description
Given a set of bus arrivals to a charging station $i= \{1,...,I\} \in \mathbb{Z}$ with a set of chargers to be queued $q
= \{1,...,Q\} \in \mathbb{Z}$ where the bus is idetified by a identificaiton number $b = \{1,...,B\} \in \mathbb{Z}$.

* Optimization Problem
:PROPERTIES:
:CUSTOM_ID: optimization-problem
:END:
This sections introduces the problem in the form of the objective functions as well MILP constraints. The objective
functions is required to allow comparisons between candidate solutions. In the context of this formulation, the
objective function is broken down into two major components as alluded in the introduction: consumption cost and demand
cost. The constraints ensure that candidate solutions are in the feasible region. They are composed of decision
variables and input variables which are unknown variables that are manipulated in the attempt to optimize the objective
functions and predefined input variables that are defined by the state of the system, respectively. Furthermore, the decision
variables have components that are directly and indirectly manipulated.

#+name: tab:variables
#+caption: Table of variables used in the paper.
| *Variable*         | *Description*                                                      |
|--------------------+--------------------------------------------------------------------|
| Input constants    |                                                                    |
| $B$                | Number of buses in use                                             |
| $I$                | Number of total visits                                             |
| $J(v,u,d)$         | Objective function                                                 |
| $K$                | Local search iteration amount                                      |
| $Q$                | Number of chargers                                                 |
| $\T$               | Time horizon                                                       |
| $\Tau$             | Temperature                                                        |
|--------------------+--------------------------------------------------------------------|
| Input variables    |                                                                    |
| $\Delta_i$         | Discharge of visit over route $i$                                  |
| $\alpha_i$         | Initial charge percentage time for visit $i$                       |
| $\beta_i$          | Final charge percentage for bus $i$ at the end of the time horizon |
| $\delta_i$         | Discharge rate for vehicle $i$                                     |
| $\epsilon_q$       | Cost of using charger $q$                                          |
| $\kappa_i$         | Battery capacity for bus $i$                                       |
| $\xi_i$            | Value indicating the next index visit $i$ will arrive              |
| $a_i$              | Arrival time of visit $i$                                          |
| $b_i$              | ID for bus visit $i$                                               |
| $e_i$              | Time visit $i$ must exit the station                               |
| $k$                | Local search iteration $k$                                         |
| $m$                | Minimum charge percentage allowed for each visit                   |
| $r_q$              | Charge rate of charger $q$                                         |
|--------------------+--------------------------------------------------------------------|
| Decision Variables |                                                                    |
| $\eta_i$           | Initial charge for visit $i$                                       |
| $d_i$              | Detach time from charger for visit $i$                             |
| $p_{dem}(t)$       | Demand cost                                                        |
| $s_i$              | Amount of time spent on charger for visit $i$ (service time)       |
| $u_i$              | Initial charge time of visit $i$                                   |
| $v_i$              | Assigned queue for visit $i$                                       |
|--------------------+--------------------------------------------------------------------|

** Parameter Definitions
*** Input Constants
*** Input Variables
The input values of any MILP system are defined prior to the solving of the system. They define initial conditions,
known state properties, etc.

*** Decision Variables
:PROPERTIES:
:CUSTOM_ID: decision-variables
:END:
Given a set of route metadata, initial charge at the start of the day, arrival times, discharge amounts, etc., a
charging solution must be generated. The key information required, known as the decision variables, are:

- $\eta_i$: initial charges for each visit $i$
- $d_i$ : detach time from the charger for each visit $i$
- $p_dem$ : The demand cost for the working day
- $u_i$ : Initial charge time of visit $i$
- $s_i$ : Service time of the charger ($s_i = d_i - u_d$)
- $v_i$ : Assigned charger for visit $i$

In section [[#sec:generators]] all but $p_dem$ and $eta_i$ will be defined. $p_dem$ will be defined in section
[[#sec:objective]], and $\eta_i$ will be defined in [[#sec:constraints]]. All the variables are defined in table
[[tab:variables]].
** Objective Function
:PROPERTIES:
:CUSTOM_ID: sec:objective
:END:
Let $J$ represent the objective function. The objective function has four main considerations:

- Charger assignment
- Demand cost
- Consumption cost
- Sufficient charge

Suppose the objective function is of the form $J = AC(u, d, v) + PC(u, d, v)$. $AC(u, d, v)$ is the assignment cost,
and $PC(u, d, v)$ is the power usage cost. The assignment cost can be represented as:

$$
AC(u,d,v) = \sum_{i=1}^I UsageCost(v_i, u_i, d_i) + ChargePenalty(\eta_i)
$$

Where $v_i$ is the charger index, $u_i$ is the initial charge time, and $d_i$ is the detach time for visit $i$.
The function $UsageCost(v,u,d)$ returns the cost of using charger $q$ multiplied by the usage time as shown in
Algorithm [[alg:usage-cost]] and $\eta_i$ is the initial charge for visit $i$. The $ChargePenalty(\eta_i)$ method
exponentially punishes the candidate solution if the initial charge for a specified visit $i$ is not above a given
threshold as described in Algorithm [[alg:charge-penalty]].

#+name: alg:usage-cost
#+begin_export latex
\begin{algorithm}[H]
\label{alg:usage-cost}
\caption{Method describing the calculation for the cost of usage for charger $q$.}
    \TitleOfAlgo{UsageCost}
    \KwIn{Charger assignment, start charge time, end charge time: (v, u, i)}
    \KwOut{Cost of use of charger}

    \Begin
    {
        \Return{$\epsilon_q[v_i](d_i - u_i)$}
    }
\end{algorithm}
#+end_export

#+name: alg:charge-penalty
#+begin_export latex
\begin{algorithm}[H]
\label{alg:charge-penalty}
\caption{Method describing the calculation for the penalty of buses not meeting the required charge threshold.}
    \TitleOfAlgo{ChargePenalty}
    \KwIn{Initial charge for visit $i$: $\eta_i$}
    \KwOut{Penalty}

    \Begin
    {
        penalty $\leftarrow$ 0\;

        \If{$m \kappa_i \geq \eta_{\xi_i}$}
        {
            penalty $\leftarrow\; exp(m - \eta_i)$\;
        }

        \Return{penalty}
    }
\end{algorithm}
#+end_export

Where $m$ is the minimum charge percentage allowed at each visit and
$\kappa_i$ is the battery capacity.

The power cost can begin to be defined with the consumption cost:

$$
PC(u,d,v) = DemandCost(schedule) + \sum_{i=1}^I  ConsumptionCost(v_i, u_i, d_i)
$$

where $ConsumptionCost(v_i, u_i, d_i)$ returns the energy in $KWH$
given the charger index $v_i$ and time spent on the charger $d_i$ as
shown in Algorithm [[alg:consumption-cost]].

#+name: alg:consumption-cost
#+begin_export latex
\begin{algorithm}[H]
\label{alg:consumption-cost}
\caption{Method describing the consumption cost for a single visit}
    \TitleOfAlgo{ConsumptionCost}
    \KwIn{Charger assignment, start charge time, end charge time: (v, u, i)}
    \KwOut{Consumption cost}

    \Begin
    {
        \Return{$r[v_i](d_i - u_i)$}
    }
\end{algorithm}
#+end_export

Peak 15 should also be taken into consideration. Peak 15 is defined as:

$$
p_{15}(t) = 1/15 \int_{t-15}^{t} p(\tau) d\tau
$$

which represents the energy used over the last 15 minutes. Because worst
case must be assumed to always ensure enough power is supplied

$$
p_{max}(t) = \text{max}_{\tau\in [0,t]}p_{15}(\tau)
$$

Which retains the largest $p_{15}$ found. The demand charge is then
determined by

$$
p_{dem}(t) = \text{max}(p_{fix},p_{max}(t))s_r
$$

where $s_r$ is the demand rate. Which, again, retains the largest
$p_{15}$ value with a starting, fixed value of $p_{fix}$. To
calculate this numerically, an integration algorithm is required to
iteratively calculate the $p_{15}(t)$. In turn, $p_{dem}(T)$ can be
defined. This process is defined in Algorithm [[alg:demand-cost]].

#+name: alg:demand-cost
#+begin_export latex
\begin{algorithm}[H]
\label{alg:demand-cost}
\caption{Algorithm to calculate the demand cost.}
    \TitleOfAlgo{DemandCost}
    \KwIn{Candidate solution: (schedule)}
    \KwOut{Demand cost: (p-dem)}

    \SetKwFunction{Integrate}{Integrate}
    \SetKwFunction{Union}{Union}

    \Begin
    {
        p15 $\leftarrow\; \emptyset$\;

        \For{dt $\leftarrow 0$ \KwTo T}
        {
            \Union{p15, \Integrate{schedule,(dt,dt+15)}}
        }

        p-old $\leftarrow$ p-new $\leftarrow$ p-dem $\leftarrow$ p-fix\;

        \ForEach{element p in p15}
        {
            p-old $\leftarrow$ p-new\;
            p-new $\leftarrow$ p\;

            \If{p-new > p-old}
            {
                p-dem $\leftarrow$ p-new\;
                p-old $\leftarrow$ p-new\;
            }
        }

        \Return{p-dem}
    }
\end{algorithm}
#+end_export

From this we can write:

$$
PC(u,d,v) = DemandCost(schedule) + \sum_{i=1}^I ConsumptionCost(v_i, u_i, d_i)
$$

** Constraints
:PROPERTIES:
:CUSTOM_ID: sec:constraints
:END:
Now that a method of calculating the fitness of a schedule has been
established, a method for determining the feasibility of a schedule must
be established. Feasible schedules require

- No overlap in time
- No overlap in space
- Bus receives enough charge
- Bus is not overcharged
- Departs on time

These set of requirements can be summarized by the constraints that
follow:

| ($u_i \geq d_j \text{ or } u_j \geq d_i) \text{ and } v_i = v_j$           | Valid queue position/time                                                       |
| $\Delta_i = \delta_i(a_{\xi_i} - d_i)$                                     | Calculate discharge of bus during route                                         |
| $\eta_{\xi_i} = \eta_i + \text{ConsumptionCost}(v_i, a_i, e_i) - \Delta_i$ | Charge constraint                                                               |
| $\kappa_i \geq \eta_i + \text{ConsumptionCost}(v_i, a_i, e_i)$             | Ensure the bus is not charged over its maximum capacity                         |
| $a_i \leq u_i \leq (T-s_i)$                                                | Arrival time < initial charge time < maximum initial charge time                |
| $d_i \leq e_i$                                                             | Detach time should be less than or equal to departure                           |
| $s_i = d_i - u_i$                                                          | Time spent on charger is equal to the difference of the attach and detach times |

Where the valid queue position/time constraint is as defined in
\cite{tutorials_point} and depicted in [[fig:valid-queue]]. Also
note that the $\eta$ constraints can only be verified /after/ the
schedule has been generated as the initial charge for each visit is
based from the previous charger selection and charge time.

#+name: fig:valid-queue
#+begin_export latex
\begin{figure}
\centering
\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid time position: $u_1 \ngeq d_2$ or $u_2 \geq d_2$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (2,0);
        \coordinate (C) at (2.5,0);
        \coordinate (D) at (4.5,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position: $u_1 \ngeq d_2$ or $u_2 \ngeq d_1$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (3.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (4.5,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position: $u_1 \ngeq d_2$ or $u_2 \ngeq d_1$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (4.5,0);
        \coordinate (C) at (1.0,0);
        \coordinate (D) at (3.0,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\caption{Set of possible collisions between two buses in the same queue.}
\label{fig:valid-queue}
\end{figure}
#+end_export

* Simulated Annealing
SA is a local search (exploitation oriented) single-solution based (as compared to population based) metaheuristic
approach in which its main advantage is simply \cite{Gendreau2018-pw}. This model is named after its analogised process
where a crystalline solid is heated then allowed to cool very slowly until it achieves its most regular possible crystal
lattice configuration \cite{Henderson}. There are five key components to SA:

- Initial Temperature
- Cooling schedule (temperature function)
- Generation mechanism
- Acceptance criteria
- Local search iteration count (temperature change counter)

The initial temperature and cooling schedule are used to regulate the speed at which the solution attempts to converge
to the best known solution. When the temperature is high, SA encourages exploration. As it cools down (in accordance to
the cooling schedule), it begins to encourage local exploitation of the solution \cite{Rutenbar_1989; @Henderson}.

** Cooling Equation (Experimental)
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
There are three basic types of cooling equations as shown in [[fig:cool]]. A linear cooling schedule is defined by

$$
\Tau[n] = \Tau[n-1] -\Delta_0
$$

with $\Tau[0] = \Tau_0$ and $\Delta_0 = 1/2\; C^\circ$ in [[fig:cool]]. A geometric cooling schedule is mostly used
in practice \cite{Keller_2019}. It is defined by

$$
\Tau[n] = \alpha \Tau[n-1]
$$

where $\alpha = 0.995$ in [[fig:cool]]. An Exponential cooling schedule is defined by the difference equation is
define as

$$
\Tau[n] = e^{\beta}\Tau[n-1]
$$

where $\beta = 0.01$ in [[fig:cool]]. The initial temperature, $T_0$, in the case of [[fig:cool]], is
set to $500^\circ\; C$ and each schedule's final temperature is $1\; C^\circ$.

#+name: fig:cool
#+caption: Cooling equations \label{fig:cool}
[[file:uml/cool-func.jpg]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
Acceptance criteria describes the method to accept or reject a given candidate solution. In SA, if a new candidate
solution is more fit than the currently stored solution it is always accepted as the new solution. However, within SA,
worse candidate solutions may be accepted as the new solution. The probability of accepting the candidate solution is
described by the function $\exp(\frac{J(new-sol) - J(old-sol)}{\Tau})$ where $J()$ is the objective functions
described in [[#sec:objective]].

** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
Generation mechanisms in SA are used to generate random solutions to propose to the optimizer. For the case of the bus
generation, five generation mechanism shall be used:

- New visit
- Slide visit
- New charger
- Remove
- New window

These generator mechanisms will in turn be utilized by three wrapper functions. One of them being to generate a set of
bus route data and the other two used to generate candidate solutions to the bus routes. These routines are defined as
follows:

- Route generation, [[fig:route]], which utilizes route metadata
  as shown [[fig:routeyaml]]
- Schedule generation, [[fig:schedule]]
- Tweak schedule, [[fig:tweak]]

*** Generators
:PROPERTIES:
:CUSTOM_ID: generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Note that to satisfy constraints, $B$ extra dummy chargers with a power of $0\; KW$ will be added
to the array of valid chargers. When a bus is not to be placed on a charger, it will be placed in the queue $v_i \in
\{Q,...,Q+b\}$. Where $Q$ is the total amount of chargers and $b$ is the bus id.

**** New visit
:PROPERTIES:
:CUSTOM_ID: new-visit
:END:
The new visit generator describes the process of moving bus $b$ from the idle queue, $v_i \in \{Q,..,Q+b\}$ to a
valid charging queue, $v_i \in \{0,..,Q\}$. A list of tuples describing valid time, $u_i$ and $d_i$, for each
charger will be listed and randomly selected using a uniform distribution. The algorithm is defined in Algorithm
[[alg:new-visit]].

#+name: alg:new-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-visit}
\caption{New visit algorithm}
    \TitleOfAlgo{New Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue and valid time region: $(v,u,d)$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{findFreeTime}{findFreeTime}

    \Begin
    {
        $a$          $\leftarrow$ route-data[$i$].$a$\;
        $e$          $\leftarrow$ route-data[$i$].$e$\;
        valid-visit  $\leftarrow \emptyset$      \;

        \For{q $\leftarrow 0$ \KwTo Q}
        {
                \For{free-region $ \leftarrow $ \KwTo charger-data[$q$]}
                {
                        \Union{valid-visit, ($q$,\findFreeTime{free-region, ($a$,$e$)})}\;
                }
        }

        \Return{$\mathbb{U}_{[valid-visit[0],valid-visit[length(valid-visit)-1]]}$}
    }
\end{algorithm}
#+end_export

Where $\mathbb{U}_[a,b]$ is the continuous uniform distribution of $a$ and $b$, =route-data= is the data generated
in =RouteGeneration= (described in [[#sec:route-gen]]), and =charger-data= are the time intervals allocated to
buses. The algorithm to find free time is defined in Algorithm [[alg:find-free-time]]. The cases are depicted in
[[fig:find-free]].

#+name: fig:find-free
#+begin_export latex
\begin{figure}
\centering
\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $L \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (2.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq U$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (3.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq L$ or $U \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (1.5,0);
        \coordinate (B) at (3.5,0);
        \coordinate (C) at (0.0,0);
        \coordinate (D) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0.0,0);
        \coordinate (B) at (5.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (3.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_1$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\caption{Outlines the different cases that requested time and charger allocated time can overlap}
\label{fig:find-free}
\end{figure}
#+end_export

#+name: alg:find-free-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:find-free-time}
\caption{Find free time algorithm searches and returns the available time frames}
    \TitleOfAlgo{Find Free Time}
    \KwIn{Lower and upper bound of available time and arrival and departure time for bus: $(L,U,a,e)$}
    \KwOut{Tuple of initial and final charge times: $(u,d)$}

    \Begin
    {
        \If{$L \leq a$ and $U \geq e$}{
                u $\leftarrow$ $\mathbb{U}_{[a,e]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,e]}$\;
        }
        \ElseIf{$L > a$ and $U \geq e$}{
                u $\leftarrow$ $\mathbb{U}_{[L,e]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,e]}$\;
        }
        \ElseIf{$L \leq a$ and $U < e$}{
                u $\leftarrow$ $\mathbb{U}_{[a,U]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,U]}$\;
        }
        \Else($L > a$ and $U < e$){
                u $\leftarrow$ $\emptyset$\;
                d $\leftarrow$ $\mathbb{U}_{[u,U]}$\;
        }

        \Return{(u,d)}
    }
\end{algorithm}
#+end_export

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because $a_i \leq u_i \leq d_i \leq e_i$ (arrival time
is less than initial charge time which is less than the detatch time which is less than the time the bus exists the
station), there may be some room to move $u_i$ and $d_i$ within the window $[a_i, e_i]$. Two new values, $u_i$
and $d_i$ are are selected with a uniform distribution to satisfy $a_i \leq u_i \leq d_i \leq e_i$.

#+name: alg:slide-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:slide-visit}
\caption{Slide Visit Algorithm}
    \TitleOfAlgo{Slide Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
        $a \leftarrow$ route-data[$i$].$a$\;
        $e \leftarrow$ route-data[$i$].$e$\;
        $u \leftarrow$ $\mathbb{U}_{[a,e]}$\;
        $d \leftarrow$ $\mathbb{U}_{[u,e]}$\;

        \Return{(v,d)}
    }
\end{algorithm}
#+end_export

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
Similar to new visit, this generator moves a bus from one queue to another; however, the new charger generator moves a
bus from one charger queue to another, $v_i \in \{0,..,Q\}$. A new charger will be selected at random with a uniform
distribution.

#+name: alg:new-charger
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-charger}
\caption{New Charger Algorithm}
    \TitleOfAlgo{New Charger}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
       $a \leftarrow$ route-data[$i$].$a$\;
       $e \leftarrow$ route-data[$i$].$e$\;
       $v \leftarrow$ route-data[$i$].$v$\;
       valid-visit  $\leftarrow \emptyset$\;

       \For{$q\; \leftarrow 0$ \KwTo $Q$ and $q \neq v$}
       {
               \For{free-region $\leftarrow$ \KwTo q.free}
               {
                       \Union{valid-visit, \findFreeTime{free-region, (a,e)}}\;
               }
       }

       \Return{$\mathbb{U}_{[valid-visit[0],valid-visit[length(valid-visit)-1]]}$}
    }
\end{algorithm}
#+end_export

**** Remove
:PROPERTIES:
:CUSTOM_ID: sec:remove
:END:
The remove generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in
\{Q,...,Q+B\}\).

#+name:alg:remove
#+begin_export latex
\begin{algorithm}[H]
\label{alg:remove}
\caption{Remove algorithm}
    \TitleOfAlgo{New Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, time region: $(v,u,d)$}

    \Begin
    {

       $v \leftarrow Q+b$                \;
       $u \leftarrow$ route-data[$i$].$u$\;
       $d \leftarrow$ route-data[$i$].$d$\;

       \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

**** New window
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
New window is a combination of the remove and then new visit generators
([[#sec:remove]] and [[#sec:new-visit]]).

#+name: alg:new-window
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-window}
\caption{New window algorithm}
    \TitleOfAlgo{New Window}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
        \SetKwFunction{NewVisit}{NewVisit}
        \SetKwFunction{Remove}{Remove}

         $v \leftarrow$ route-data[$i$].$v$\;
         $u \leftarrow$ route-data[$i$].$u$\;
         $d \leftarrow$ route-data[$i$].$d$\;
        $(v,u,d)$ = \Remove{$v,u,d$}\;
        $(v,u,d)$ = \NewVisit{$v,u,d$}\;

        \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: generator-wrappers
:END:
This section covers the algorithms utilized to select and execute
different generation processes for the SA process.

**** Route Generation
:PROPERTIES:
:CUSTOM_ID: sec:route-gen
:END:
The objective of route generation is to create a set of metadata about
bus routes given the information in [[fig:routeyaml]].
Specifically, the objective is to generate $I$ routes for $B$ buses.
Each visit will have

- Initial charge (for first visit only)
- Arrival time
- Departure time
- Final charge (for finial visit only)

This is created by following the "GenerateSchedule" state in the state
diagram found in [[fig:route]]. In essence the logic is as
follows: Generate $B$ random numbers that add up to $I$ visits (with
a minimum amount of visits set for each bus). For each bus and for each
visit, set a departure time that is between the range [min_rest,
max_rest] ([[fig:routeyaml]]), set the next arrival time to be
$j \cdot \frac{T}{\text{number-of-bus-visits}}$ where $j$ is the
$j^{th}$ visit for bus $b$. Finally, calculate the amount of
discharge from previous arrival to the departure time.

#+name: alg:route-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:route-generation}
\caption{Route generation algorithm}
    \TitleOfAlgo{RouteGeneration}
    \KwIn{Route YAML metadata path: (path)}
    \KwOut{Array of route events: (route-data)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NumBusVisits}{NumBusVisits}
    \SetKwFunction{DepartureTime}{DepartureTime}
    \SetKwFunction{ArrivalTimeNew}{ArrivalTimeNew}
    \SetKwFunction{Discharge}{Discharge}
    \SetKwFunction{SortByArrival}{SortByArrival}
    \SetKwFunction{Feasible}{Feasible}

    \Begin
    {
        \While{!schedule-created}
        {
            arrival-new $\leftarrow$ 0.0\;
            arrival-old $\leftarrow$ 0.0\;
            departure-time $\leftarrow$ 0.0\;
            num-visit $\leftarrow$ \NumBusVisits{B}\;
            schedule-created $\leftarrow$ false\;

            \For{$b \in B$}
            {
                \For{$n \in num-visit[b]$}
                {
                    arrival-old $\leftarrow$ arrival-new\;

                    \If{$j = num-visit[b]$}{final-visit = true\;}
                    \Else{final-visit = false\;}

                    departure-time $\leftarrow$ \DepartureTime{arrival-old, final-visit}\;
                    arrival-new $\leftarrow$ current-visit*$\frac{T}{total-visit-count}$\;
                    discharge $\leftarrow$ discharge-rate*(next-arrival-depart-time)    \;
                    \Union{route-data, (arrival-old, departure-time, discharge)}\;
                }
            }

            schedule-created $\leftarrow$ \Feasible{route-data}\;
            \SortByArrival{route-data}\;
        }

    }
\end{algorithm}
#+end_export

#+name: alg:departure-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:departure-time}
\caption{Departure time algorithm}
    \TitleOfAlgo{DepartureTime}
    \KwIn{Previous arrival and final visit flag: (arrival-old and final-visit)}
    \KwOut{Next departure time: (depart)}

    \Begin
    {
        \If{final-visit}
        {
            depart $\leftarrow$ T\;
        }
        \Else
        {
            depart $\leftarrow$ arrival-old + $\mathbb{U}_{[min-rest,max-rest]}$\;
        }

        \Return{depart}
    }
\end{algorithm}
#+end_export

Where =discharge-rate= is read from YAML data shown in
[[fig:routeyaml]], the =Feasible= method is used to determine if
the generated schedule is valid (conditions covered in
[[#sec:constraints]]).

**** Schedule Generation
:PROPERTIES:
:CUSTOM_ID: schedule-generation
:END:
The objective of this generator is to generate a candidate solution to
the given schedule. To generate a candidate solution the generator is
given the route schedule data that was previous generated. A bus is
picked at random, $b \in B$, then a random route is picked for bus
$b$. The new arrival generator is then utilized. This process is
repeated for each visit. The state diagram is depicted in the state
digram in [[fig:schedule]] and outlined in Algorithm
[[alg:schedule-generation]].

#+name: alg:schedule-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:schedule-generation}
\caption{Schedule generation algorithm}
    \TitleOfAlgo{ScheduleGeneration}
    \KwIn{Route data: (route-data)}
    \KwOut{Candidate charging schedule: (schedule)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        schedule $\leftarrow\; \emptyset$\;
        \For {i in I}
        {
            bus $\leftarrow\; \mathbb{U}_{[0,B]}$\;
            visit $\leftarrow\; \mathbb{U}_{[0,total-visit-count]}$\;
            \Union{schedule,\NewVisit{(visit.a, visit.e)}}\;
        }
            \Return{schedule}
    }
\end{algorithm}
#+end_export

**** Tweak Schedule
:PROPERTIES:
:CUSTOM_ID: tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit a given solution
\cite{radosavljevic2018metaheuristic}. The method that will be employed to exploit the given solution is as follows:
pick a bus, pick a visit, pick a generator. This state diagram is depicted in [[fig:tweak]] and outlined in Algorithm
[[alg:tweak-schedule]].

#+name: alg:tweak-schedule
#+begin_export latex
\begin{algorithm}[H]
\label{alg:tweak-schedule}
\caption{Tweak schedule algorithm}
    \TitleOfAlgo{TweakSchedule}
    \KwIn{Schedule candidate solution: (schedule)}
    \KwOut{Perturbed schedule: (schedule)}

    \SetKwFunction{GeneratorCallback}{GeneratorCallback}

    \Begin
    {
        \For {i in I}
        {
            bus $\leftarrow\; \mathbb{U}_{[0,B]}$\;
            visit $\leftarrow\; \mathbb{U}_{[0,total-visit-count]}$\;
            generator $\leftarrow\; \mathbb{U}_{[0,generator-count]}$\;
            schedule $\leftarrow$ \GeneratorCallback[generator]{(i, route-data, charger-data)}\;
        }

        \Return{schedule}
    }
\end{algorithm}
#+end_export

* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: optimization-algorithm
:END:
This final section combines the generation algorithms and the
optimization problem into a single algorithm. The objective is to
outline the SA process from start to finish. Algorithm
[[alg:route-generation]] generates a set of bus routes utilizing
the route metadata in [[fig:routeyaml]]. The initial temperature
and cooling schedule will be selected and passed into the SA
optimization algorithm. A new candidate solution will be generated. For
each step in the cooling schedule will have $K$ iterations to attempt
to find a local maxima. Each perturbation to the system is then compared
to the current candidate solution. If the new candidate solution is
better it is kept; however, if the candidate solution is worse, the
solution may still be kept with a probability
$\exp(\text{del-sol}/\Tau)$ as described in [[#sec:acceptance]].
This process is summarized in Algorithm [[alg:sa-pap]].

#+name: alg:sa-pap
#+begin_export latex
\begin{algorithm}[H]
\label{alg:sa-pap}
\caption{Simulated annealing approach to the position allocation problem}
    \TitleOfAlgo{SA PAP}
    \KwIn{Bus route metadata: (file-path)}
    \KwOut{Optimal charging schedule: (schedule)}

    \SetKwFunction{InitTemp}{InitTemp}
    \SetKwFunction{GetCoolSchedule}{GetCoolSchedule}
    \SetKwFunction{LoadYaml}{LoadYaml}
    \SetKwFunction{RouteGeneration}{RouteGeneration}
    \SetKwFunction{J}{J}
    \SetKwFunction{ScheduleGeneration}{ScheduleGeneration}
    \SetKwFunction{TweakSchedule}{TweakSchedule}

    \Begin
    {
        $\Tau_0\; \leftarrow$ \InitTemp{}\;
        $\Tau_{schedule}\; \leftarrow$ \GetCoolSchedule{}\;

        route-metadata $\leftarrow$ \LoadYaml{file-path}\;
        routes $\leftarrow$ \RouteGeneration{route-metadata}\;

        best-solution $\leftarrow v \in$ \ScheduleGeneration{routes}\;

        \ForEach{$\Tau \in \Tau_{schedule}(\Tau_0)$}
        {
            candidate-solution $\leftarrow$ \ScheduleGeneration{routes}\;

            \ForEach{$k \in K$}
            {
                del-sol $\leftarrow$ \J{candidate-solution} - \J{best-solution}\;

                \If{del-sol $\leq$ 0}
                {
                   best-solution $\leftarrow$ candidate-solution\;
                }
                \ElseIf{del-sol $\geq$ 0}
                {
                    best-solution $\leftarrow$ candidate-solution with probability $\exp$(del-sol$\tau_k$)\;
                }

                schedule $\leftarrow$ \TweakSchedule{schedule}\;
            }
        }
    }
\end{algorithm}
#+end_export

\bibliographystyle{plain}
\bibliography{main}

#+name: fig:route
#+caption: Route generation state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/route_generation.png]]

#+name: fig:routeyaml
#+caption: Route YAML file with example data
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/route_yaml.png]]

#+name: fig:schedule
#+caption: Charge solution state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/charge_solution.png]]

#+name: fig:tweak
#+caption: Solution tweak state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.2\textwidth
[[file:uml/charge_tweak.png]]
