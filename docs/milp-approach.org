#+TITLE: Bus Charging Schedule Simulated Annealing with MILP Constraints
#+DATE: \today
#+EMAIL: A01704744@usu.edu
#+LANGUAGE: en

# =========================================================================================================================
# Org LaTeX options
#+OPTIONS: tex:t

# =========================================================================================================================
# LaTeX packages
#+LATEX_CLASS: article
#+latex_header: \usepackage{lipsum}                         % Dummy filler text
#+latex_header: \usepackage{amsfonts}                       % Cool math fonts
#+latex_header: \setlength\parindent{0pt}                   % No indent for paragraphs

# =========================================================================================================================
# `autoref' formatting
#+latex_header: \renewcommand*{\sectionautorefname}{Section}
#+latex_header: \renewcommand*{\subsectionautorefname}{Subsection}
#+latex_header: \renewcommand*{\subsubsectionautorefname}{Subsubsection}
#+latex_header: \renewcommand*{\paragraphautorefname}{Paragraph}

# =========================================================================================================================
# Custom commands
#+latex_header: \newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{gray}{#1}}

#+latex_header: \newcommand{\T}{\mathcal{T}}                % To make it clear the difference
#+latex_header: \newcommand{\Tau}{T}                        % between Tau and T
#+latex_header: \newcommand{\AC}{AC(u_i, d_i, v_i, \eta_i)} % Set the parameters for AC once
#+latex_header: \newcommand{\PC}{PC(u_i, d_i, v_i)}         % Set the parameters for PC once
#+latex_header: \newcommand{\Not}{\textbf{not }}            % Custom `not' operator
#+latex_header: \newcommand{\visit}{(b_i, a_i, e_i, u_i, d_i, v_i, \eta_i, \xi_i)}
                                                            # Single visit tuple
#+latex_header: \newcommand{\I}{\mathbb{I}}                 % Set of visit tuples
#+latex_header: \newcommand{\C}{\mathbb{C}}                 % Charger availability information
#+latex_header: \newcommand{\Sol}{\mathbb{S}}               % A shorthand for visit tuple

#+latex_header: \newcommand{\Iset}{\mathcal{I}}             % Set of visits 1-I
#+latex_header: \newcommand{\Bset}{\mathcal{B}}             % Set of visits 1-B
#+latex_header: \newcommand{\Qset}{\mathcal{Q}}             % Set of visits 1-Q
#+latex_header: \newcommand{\Jset}{\mathcal{J}}             % Set of visits 1-J

# =========================================================================================================================
# More document configuration
#+begin_export latex
\parskip 3mm                                % Set the vetical space between paragraphs
\let\ref\autoref                            % Redifine `\ref` as `\autoref` because lazy
\SetCommentSty{mycommfont}                  % Set the comment color
#+end_export

# =========================================================================================================================
# Document

* Introduction
:PROPERTIES:
:CUSTOM_ID: sec:introduction
:END:
This document outlines the simulated annealing (SA) approach to the bus charging scheduling problem utilizing Mixed
Integer Linear Programming (MILP) constraints as the method of determining feasible charging schedules. The problem
statement is as follows: given a set of routes for a fleet of Battery Electric Buses (BEB), generate an optimal charging
schedule to minimize the consumption cost (amount of electricity used over a certain time) and the demand cost (rate at
which electricity is being used) within the constraints that the buses must maintain sufficient charge to complete the
working day and do not have any delays in their respective routes.

Simulated Annealing (SA) shall be introduced and utilized as a means of finding the global optimum. The SA algorithm
shall be constrained by a set of Mixed Integer Linear Program (MILP) constraints derived from the Position Allocation
Problem (PAP). These constraints are set in place to ensure validity of the proposed charging schedules. A set of
objective functions describing consumption cost and demand cost, as stated above, shall be minimized to reduce power
consumption and total cost of using the BEBs.

* Problem Description
:PROPERTIES:
:CUSTOM_ID: sec:problem-description
:END:
Given a set of bus arrivals to a charging station $i \in \{1,...,I\} = \Iset \subset \mathcal{Z}$ with a set of chargers
to be queued $q \in \{1,...,Q\} = \Qset \subset \mathcal{Z}$ where the bus is indicated by an identification number $b
\in \{1,...,B\} = \Bset \in \mathcal{Z}$. Each bus arrival, $i$, can be represented by the tuple: $\visit$, in which
the ordered elements denote the bus identification number arrival time to the station, departure time from the station,
initial charging time, charge end time, the charger queue for the bus to be placed into, and the initial State Of Charge
(SOC).

It is assumed that each visit occurs over the time horizon $T$. The set of all arrivals is represented by the set $\I =
\{\visit: b_i, \xi_i \in B, a_i, e_i, u_i, d_i \in T, v_i \in Q\}$. The concept of "arrivals" is derived from the PAP
\cite{Qarebagh2019}. This idea of arrivals is useful in the sense that it is easy to describe the state of any arbitrary
arrival; however, it also assumes that each arrival is unique (i.e. no two bus arrives twice) therefore a system must be
put in place to track each bus over each arrival. That is why a bus identifier is placed in the tuple, and in that way
each bus can be tracked over each arrival.

For each arrival a bus must be placed in a singular queue, $v_i \in Q$. The charger $q$ is assumed to be either a fast
or slow charger. The bus is not allowed to change queues mid-charge. The amount of time the bus is allowed to charge is
dictated by the scheduled arrival time and required departure time, $[a_i, e_i]$. Although an arrival must be placed in
a queue, if a bus does not require much charge, or none at all, partial charges, or no charging, is allowed. It is not
allowed for the bus to charge over its battery capacity limit. The battery charging rate is modeled as linear, which
remains accurate up to about an SOC of 80% charge \cite{Li2016}.

Each bus arrival, with the exception of the last arrival for each bus, has a paired "route" that the bus must perform.
This route, as one would expect, causes the bus to discharge by some certain amount. This paper assumes an average
discharge over a period of time allowing an estimation to be calculated for each route, $\Delta_i$. The charge supplied
while at the station is assumed to supply enough charge for each route (battery charge does not deplete to zero) with an
additional battery capacity percentage, $m$, acting as a safety factor.

The scheduler's task shall be to schedule the set of arrivals $\I$ to fulfill the minimum charge requirements
over the time horizon $T$ as well as minimize the demand cost as well as minimize over the consumption cost. The
objective function and constraints are discussed in further detail in section [[#sec:objective-function]].

* Optimization Problem
:PROPERTIES:
:CUSTOM_ID: optimization-problem
:END:
This sections introduces the problem in the form of the objective function as well MILP constraints. The objective
function is required to allow comparisons between candidate solutions. In the context of this formulation, the objective
function is broken down into two major components as alluded in the introduction: consumption cost and demand cost. The
constraints ensure that candidate solutions are in the feasible region. They are composed of a series of equations
defined by decision variables which are unknown variables that are manipulated in the attempt to optimize the objective
functions and input variables predefined input variables that are assumed to be known. Furthermore, the decision
variables have components that are directly and indirectly manipulated. This will be further discussed in
[[#sec:decision-variables]].

#+name: tab:variables
#+caption: Table of variables used in the paper.
| *Variable*         | *Description*                                                      |
|--------------------+--------------------------------------------------------------------|
| Input constants    |                                                                    |
| $C$                | Penalty method gain factor                                         |
| $B$                | Number of buses in use                                             |
| $I$                | Number of total visits                                             |
| $J(v,u,d)$         | Objective function                                                 |
| $K$                | Local search iteration amount                                      |
| $Q$                | Number of chargers                                                 |
| $\T$               | Time horizon                                                       |
| $\Tau$             | Temperature                                                        |
|--------------------+--------------------------------------------------------------------|
| Input variables    |                                                                    |
| $\Delta_i$         | Discharge of visit over route $i$                                  |
| $\alpha_b$         | Initial charge percentage time for bus $b$                         |
| $\beta_i$          | Final charge percentage for bus $i$ at the end of the time horizon |
| $\delta_i$         | Discharge rate for vehicle $i$ per mile                            |
| $\epsilon_q$       | Cost of using charger $q$                                          |
| $\kappa_b$         | Battery capacity for bus $b$                                       |
| $\rho_i$           | Route distance after visit $i$                                     |
| $\xi_i$            | Value indicating the next index visit $i$ will arrive              |
| $a_i$              | Arrival time of visit $i$                                          |
| $b_i$              | ID for bus visit $i$                                               |
| $e_i$              | Time visit $i$ must exit the station                               |
| $k$                | Local search iteration $k$                                         |
| $m$                | Minimum charge percentage allowed for each visit                   |
| $r_q$              | Charge rate of charger $q$                                         |
|--------------------+--------------------------------------------------------------------|
| Decision Variables |                                                                    |
| $\eta_i$           | Initial charge for visit $i$                                       |
| $\phi_i$           | Binary term to enable/disable charge penalty for visit $i$         |
| $\psi_{ij}$        | Tracks spatial overlap for visit pair $(i,j)$                      |
| $\sigma_{ij}$      | Tracks temporal overlap for visit pair $(i,j)$                     |
| $d_i$              | Detach time from charger for visit $i$                             |
| $p_{dem}(t)$       | Demand cost                                                        |
| $s_i$              | Amount of time spent on charger for visit $i$ (service time)       |
| $u_i$              | Initial charge time of visit $i$                                   |
| $v_i$              | Assigned queue for visit $i$                                       |
|--------------------+--------------------------------------------------------------------|

** Parameter Definitions
:PROPERTIES:
:CUSTOM_ID: sec:parameter-definitions
:END:
This section defines the input variables and decision variables used by the system. The input variables are the
parameters that are assumed to be known prior to optimizing the system. The decision variables are the values that the
SA algorithm has the freedom to manipulate. The values produced by the SA algorithm will be interpreted as a candidate
charging solution. This is further described in [[#sec:simulated-annealing]].

*** Input Variables
:PROPERTIES:
:CUSTOM_ID: sec:input-variables
:END:
The input values of any MILP system are defined prior to the solving of the system. They define initial conditions,
known state properties, etc. Roughly following the order in [[tab:variables]], each variable will be introduced.

$\Delta_i$ is the amount power required to complete the bus route after visit $i$. Because there is no route after the
last visit, $\Delta_I = 0$. The discharge for visit $i$ is defined by equation \ref{eq:discharge}.

#+begin_export latex
\begin{equation}
\label{eq:discharge}
\Delta_i = \delta_i * \rho_i
\end{equation}
#+end_export

Where $\delta_i$ is the amount of energy consumed by the bus per mile and $\rho_i$ is the route mileage after
visit $i$. As discussed before, since there is no route after the last visit $\rho_I = 0$. $\alpha_b$ is the initial
SOC percentage of bus $b$ at the beginning of the working day. The initial SOC for bus $b$ can be represented as

#+begin_export latex
\begin{equation}
\eta_{i_0^b} = \alpha_b * \kappa_b \text{.}
\end{equation}
#+end_export

Where $\kappa_b$ is the battery capacity for bus $b$, $\eta_{i_0^b}$ is special notation that will temporarily be used
to indicate the initial charge for bus $b$. $\eta_i$ will be further discussed in [[#sec:decision-variables]]. $\epsilon_q$
is the cost for assigning a charger to queue $q$. This parameter is utilized by the objective function and is further
discussed in [[#sec:objective-function]]. $\xi_i$ represents the next arrival index for bus $b_i$. In other words, given a
set of bus visit IDs $b = \{ 1,2,3,1\}$. Using a starting index of 1, $\xi_1 = 4$. $a_i$ and $e_i$ are the arrival and
departure times of bus visit $i$ to the station, respectively. $k$ represents the local iteration search for the SA
algorithm. This is further discussed in [[#sec:simulated-annealing]]. Lastly, $r_q$ represents the rate of charge for the
charger in queue $q$. As will be discussed in [[#sec:objective-function]], fast chargers and slow chargers relate to high
and low costs, $\epsilon_q$, respectively.

*** Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:decision-variables
:END:
Decision variables are the defined by the optimizer and are therefore unknown prior to running the optimization
algorithm. In this case the optimizer is SA. Once SA has been ran and each of the decision variables have been specified
and the fitness of the solution is defined by the objection functions outlined in [[#sec:objective-function]] are
determined. The variables will be broken into two sections: direct and indirect decision variables. Decision variables
that are direct are values that the system has direct control over and indirect variables are those that are influenced
by the direct.

**** Direct Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:direct-decision-variables
:END:
Decision variables that are direct are variables that can be immediately chosen by SA. The first two variables are $u_i$
and $d_i$. They represent the initial and final charging times. These values must remain within range of the arrival
time and departure time for visit $i$, $[a_i, e_i]$. The last direct decision variable is the queue that bus visit $i$
can be placed in to charge, $v_i \in q$.

**** Indirect Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:indirect-decision-variables
:END:
Indirect decision variables are variables that are dependent on direct decision variables. For example $\eta_i$ is the
initial charge for visit $i$. These variables are chained together per bus by using the bus identifier, $b$, and next
index, $\xi_i$. The initial charges must be chained so that the battery charge can be calculated per bus as it is
charged and discharged over each visit, $[u_i, d_i]$. $\phi_i$ is a boolean decision variable, $\phi_i \in \{0,1\}$,
that either enables or disables the charge penalty defined in [[#sec:objective-function]]. $\sigma_{ij}$ and $\psi_{ij}$ are
used to indicate whether a visit pair $(i,j)$ overlap the same space as show in [[fig:spacial-and-temporal-constr]]. These
variables will be further elaborated on in [[#sec:constraints]]. $p_{dem}$ is the demand cost of the overall charging
schedule. It is calculated at after all the decision variables have been assigned. This is further described in
[[#sec:objective-function]].

** Objective Function
:PROPERTIES:
:CUSTOM_ID: sec:objective-function
:END:
The objective function is used to compare the fitness of different candidate solutions against one another. This
objective function takes in a set input variables and decision variables to calculate some value of measure. The
calculated objective function value can either be maximized or minimized. The desired option is dependent on the problem
to be solved as well as the formulation of said objective function. Let $J$ represent the objective function. The
objective function for this problem has four main considerations: charger assignment, consumption cost, demand cost, and
sufficient charge.

Suppose the objective function is of the form $\text{min } J = \AC + \PC$. $\AC$ is the assignment cost, and $\PC$ is the power
usage cost. The assignment cost represents the costs of assigning a bus to a particular queue as well as the chosen
charging period, $[u_i, d_i]$ as shown in [[eq:ac]].

#+name: eq:ac
#+begin_export latex
\begin{equation}
\label{eq:ac}
\AC = \sum_{i=1}^I \epsilon_{v_i}(d_i - u_i) + \frac{1}{2} C \phi_i (\eta_i - m \kappa_i)^{2}
\end{equation}
#+end_export

Where $v_i \in q$ is the charger index, $u_i$ is the initial charge time, $d_i$ is the detach time for visit $i$,
$\psi_i$ is a binary decision variable, $m$ is the minimum charge percentage allowed, $\kappa_i$ is the battery capacity
for visit $i$, and $\eta_i$ is the initial charge for visit $i$. The first term in the summation represents the
calculation of the cost for assigning a bus to queue $q$ (i.e. cost of using the charger multiplied by the usage time).
The second term is the penalty function that is either enabled or disabled by $\phi_i$ which is discussed in
[[#sec:constraints]]. This form is the most common form that penalty methods are found in \cite{Luenberger2008}. Note that
the variables $\psi_i$ and $\eta_i$ are both decision variables that are being multiplied together. This is called a
bilinear term. Using a traditional MILP solver, this would require linearization \cite{Rodriguez2013}; however, because
SA handles nonlinearities easily these bilinear terms will be ignored \cite{Radosavljevic2018-jc}.

The power cost contains the demand cost and the consumption cost. It can be divided into two components: demand cost and
the consumption cost. The demand cost quantifies the amount of power being used over a given period and adjusts the cost
accordingly. The consumption cost calculates the total amount of power being consumed by the chargers. The power cost is
shown in [[eq:pc]]. Note that the demand cost is written as a function. This is because it is calculated post generation of
the candidate solution with no obvious MILP representation.

#+name: eq:pc
#+begin_export latex
\begin{equation}
\label{eq:pc}
\PC = DemandCost(schedule) + \sum_{i=1}^I r[v_i](d_i - u_i)
\end{equation}
#+end_export

As stated before, the demand cost is calculated based on 15 minute increments (0.25 hours). This cost is also referred
to as the peak 15. The peak 15 is represented by [[eq:p15]].

#+name: eq:p15
#+begin_export latex
\begin{equation}
\label{eq:p15}
p_{15}(t) = 0.25 \int_{t-15}^{t} p(\tau) d\tau
\end{equation}
#+end_export

Which represents the energy used over the last 15 minutes. Because worst case must be assumed to always ensure enough
power is supplied, the maximum value found is retained as represented in [[eq:pmax]].

#+name: eq:pmax
#+begin_export latex
\begin{equation}
\label{eq:pmax}
p_{max}(t) = \text{max}_{\tau \in [0,t]}p_{15}(\tau)
\end{equation}
#+end_export

Because the cost has a minimum threshold, a fixed minimum cost is introduced. In a similar manner as $p_{max}$, the
maximum value is retained.

#+name: eq:pdem
#+begin_export latex
\begin{equation}
\label{eq:pdem}
p_{dem}(t) = \text{max}(p_{fix},p_{max}(t))s_r
\end{equation}
#+end_export

Where $s_r$ is the demand rate. [[eq:pdem]], again, retains the largest $p_{15}$ value with a starting fixed value of
$p_{fix}$. To calculate this numerically, an integration algorithm is required to iteratively calculate the $p_{15}(t)$.
In turn, $p_{dem}(T)$ can be defined. This process is defined in Algorithm [[alg:demand-cost]].

#+name: alg:demand-cost
#+BEGIN_EXPORT latex
\begin{algorithm}[H]
\label{alg:demand-cost}
\caption{Algorithm to calculate the demand cost.}
    \LinesNumbered
    \TitleOfAlgo{DemandCost}
    \KwIn{Candidate solution: (schedule)}
    \KwOut{Demand cost: (p-dem)}

    \SetKwFunction{Integrate}{Integrate}
    \SetKwFunction{Union}{Union}

    \Begin
    {
        p15 $\leftarrow\; \varnothing$\;

        \For{dt $\leftarrow 0$ \KwTo T}
        {
            \Union{p15, \Integrate{schedule,(dt,dt+0.25)}}
        }

        p-old $\leftarrow$ p-new $\leftarrow$ p-dem $\leftarrow$ p-fix\;

        \ForEach{element p in p15}
        {
            p-old $\leftarrow$ p-new\;
            p-new $\leftarrow$ p\;

            \If{p-new > p-old}
            {
                p-dem $\leftarrow$ p-new\;
                p-old $\leftarrow$ p-new\;
            }
        }

        \Return{p-dem}}
\end{algorithm}
#+END_EXPORT

Where =schedule= is the set $\I = \{ (b_i, a_i, e_i, u_i, d_i, v_i, \eta_i): b_i \in B, a_i, e_i, u_i, d_i \in
T, v_i \in Q\}$ and =p-fix= is the initial, fixed cost.

** Constraints
:PROPERTIES:
:CUSTOM_ID: sec:constraints
:END:
Now that a method of calculating the fitness of a schedule has been established, a method for determining the
feasibility of a schedule must be established. Feasible schedules require that the schedule maintain a certain list of
properties. These properties are enforced by a set of constraints derived from the MILP PAP. The constraints must ensure
no overlap temporally or spatially, receives enough charge to complete route after each visit $i$, bus visit $i$ cannot
be over charged, each visit, $i$, departs on time. The aforementioned constraints are shown in [[eq:constraints]].

#+name: eq:constraints
#+begin_export latex
\begin{subequations}
\label{eq:constraints}
\begin{equation}
    \label{seq:c0}
    u_i - d_j - (\sigma_{ij} - 1)T \ge 0
\end{equation}
\begin{equation}
    \label{seq:c1}
    v_i - v_j - (\psi_{ij} - 1)Q \ge 0
\end{equation}
\begin{equation}
    \label{seq:c2}
    \sigma_{ij} + \sigma_{ji} \le 1
\end{equation}
\begin{equation}
   \label{seq:c3}
    \psi_{ij} + \psi_{ji} \le 1
\end{equation}
\begin{equation}
    \label{seq:c4}
    \sigma_{ij} + \sigma_{ji} + \psi_{ij} + \psi_{ji} \ge 1
\end{equation}
\begin{equation}
    \label{seq:c5}
    \Delta_i = \delta_i(a_{\xi_i} - d_i)
\end{equation}
\begin{equation}
    \label{seq:c6}
     \eta_{\xi_i} = \eta_i + r_{v_i}(d_i - u_i) - \Delta_i
\end{equation}
\begin{equation}
    \label{seq:c7}
    \kappa_i \geq \eta_i + r_{v_i}(d_i - u_i)
\end{equation}
\begin{equation}
    \label{seq:c8}
    \eta_i - m_{k_i} \le T (1 - \phi_{i})
\end{equation}
\begin{equation}
    \label{seq:c9}
    \eta_i - m_{k_i} < T \phi_{i}
\end{equation}
\begin{equation}
    \label{seq:c10}
    a_i \leq u_i \leq d_i \le e_i \le T
\end{equation}
\end{subequations}
#+end_export

# Org mode is a little silly and does not take normal referencing syntax. This note is for future reference.
Where the valid queue \ref{seq:c0} - \ref{seq:c4} define the spatial and temporal constraints of the system. These
constraint enforce that the buses are placed in such a way that only one bus is allowed at a charger at any given time.
Particularly \ref{seq:c0} determines if the initial charge time of visit $i$ is after the final charge time of visit
$j$. Similarly, \ref{seq:c1} determines if visit $i$ or visit $j$ are scheduled to be on the same queue. \ref{seq:c2}
describes whether one of the visits come after the other temporally while \ref{seq:c3} describes if the chargers are
placed in different queues. \ref{seq:c4} pulls all the previous constraints together and verifies that at least one of
the conditions are true for each visit pair $(i,j)$. The concept of the temporal and spatial constraints can be
visualized by [[fig:spacial-and-temporal-constr]]. The y-axis represents the possible queues for a bus visit to be placed
into and the x-axis represents the time that can be reserved for each visit. The shaded rectangles represent time that
has been scheduled for each bus visit. The set of constraints \ref{seq:c0} - \ref{seq:c4} aim to ensure that these
shaded rectangles never overlap. \ref{seq:c5} calculates the discharge for the route after visit $i$. \ref{seq:c6}
calculates the initial charge for the next visit for bus $b_i$. \ref{seq:c7} ensures that the bus is not being over
charged. \ref{seq:c8} and \ref{seq:c9} are used to enable and disable the penalty method in [[eq:ac]]. This is done by
checking if the initial charge for visit $i$ is greater than or equal to the minimum allowed charge. \ref{seq:c10}
ensures the continuity of the times (i.e. the arrival time is less than the initial charge which is less than the detach
time which is less than the time the bus exits the station and all must be less than the time horizon).

#+name: fig:spacial-and-temporal-constr
#+begin_export latex
\input{img/spacial-temporal-constr.tex}
#+end_export

* Simulated Annealing
:PROPERTIES:
:CUSTOM_ID: sec:simulated-annealing
:END:
SA is a local search (exploitation oriented) single-solution based (as compared to population based) metaheuristic
approach in which its main advantage is its simplicity both theoretically and in its implementation as well its inherit
ability to overcome nonlinearities \cite{Gendreau2018-pw, Radosavljevic2018-jc}. This model is named after its
analogized process where a crystalline solid is heated then allowed to cool very slowly until it achieves its most
regular possible crystal lattice configuration \cite{Henderson}. There are five key components to SA: initial
temperature, cooling schedule (temperature function), generation mechanism, acceptance criteria, local search iteration
count (temperature change counter) \cite{Keller_2019}.

** Cooling Equation (Experimental)
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
The initial temperature and cooling schedule are used to regulate the speed at which the solution attempts to converge
to the best known solution. When the temperature is high, SA encourages exploration. As it cools down (in accordance to
the cooling schedule), it begins to encourage local exploitation of the solution \cite{Rutenbar_1989, Henderson}. There
are three basic types of cooling equations as shown in [[fig:cool]] \cite{Keller_2019}. The different types merely dictate
the rate at which we begin disallowing exploration. A linear cooling schedule is defined by [[eq:cool0]].

#+name: eq:cool0
#+begin_export latex
\begin{equation}
\label{eq:cool0}
\Tau[n] = \Tau[n-1] -\Delta_0
\end{equation}
#+end_export

with $\Tau[0] = \Tau_0$ and $\Delta_0 = 1/2\; C^\circ$ in [[fig:cool]]. A geometric cooling schedule is mostly used
in practice \cite{Keller_2019}. It is defined by [[eq:cool1]].

#+name: eq:cool1
#+begin_export latex
\begin{equation}
\label{eq:cool1}
\Tau[n] = \alpha \Tau[n-1]
\end{equation}
#+end_export

where $\alpha = 0.995$ in [[fig:cool]]. An Exponential cooling schedule is defined by the difference equation is
define as [[eq:cool2]].

#+name: eq:cool2
#+begin_export latex
\begin{equation}
\label{eq:cool2}
\Tau[n] = e^{\beta}\Tau[n-1]
\end{equation}
#+end_export

where $\beta = 0.01$ in [[fig:cool]]. The initial temperature, $T_0$, in the case of [[fig:cool]], is
set to $500^\circ\; C$ and each schedule's final temperature is $1\; C^\circ$.

#+name: fig:cool
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
#+caption: Cooling equations \label{fig:cool}
[[file:img/cool-func.jpg]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
Acceptance criteria describes the method to accept or reject a given candidate solution. In SA, if a new candidate
solution is more fit than the currently stored solution it is always accepted as the new solution. However, within SA,
worse candidate solutions may be accepted as the new solution. The probability of accepting the candidate solution is
described by the function $\exp(\frac{J(x) - J(x')}{\Tau})$ where $J(\cdot)$ is the objective functions described in
[[#sec:objective-function]]. The probability of acceptance is a function of the cooling equation just described and
difference of the current solution and a new candidate solution. Let $\Delta E \equiv J(x) - J(x')$ where $x$ is the
current solution and $x'$ is the new candidate solution. The probability of acceptance of $x'$ is defined by
[[eq:candaccept]] \cite{Keller_2019}.

#+name: eq:candaccept
#+begin_export latex
\begin{equation}
\label{eq:candaccept}
f(x,x',T) =
\begin{cases}
  1                 & \Delta E > 0 \\
  e^{- \frac{\Delta E}{T}} & \text{otherwise}
\end{cases}
\end{equation}
#+end_export

** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
Generation mechanisms in SA are used to generate random solutions to propose to the optimizer, these are known as
candidate solutions. In the case of the problem statement made in [[#sec:problem-description]], five generation mechanism
shall be used: new visit, slide visit, new charger, remove, new window. The purpose of each of these generators is to
assign new visits to a charger, adjust a bus visits initial and final charge time within the same time frame/queue,
remove a bus from a charger, and place a bus visit into a new time slot/queue. Each generator will be discussed in more
detail in [[#sec:generators]].

These generator mechanisms will in turn be utilized by three wrapper functions. The purpose of the route generation to
create a set of bus route data to feed to the SA algorithm. Although, strictly speaking, is not a part of the SA
algorithm. It is vital in specifying the initial conditions and "setting the stage" for the SA algorithm to solve. The
schedule generation is to used create candidate solutions for SA to compare with other solutions, and the perturb
schedule generator is used to take a candidate solution and alter it slightly in an attempt to fall into a global/local
minimum.

*** Generator Input/Output
:PROPERTIES:
:CUSTOM_ID: sec:generator-input-output
:END:
This section discusses in detail the expected inputs and output of each generator. It is important to discuss these
parameters in order to have an understanding of the generating algorithms derived. The input consists of the bus visit
index of interest, information about the current state of arrivals, $\I$, and the current state of the chargers'
availability, $\C$. The output of each generator affects the tuple of decision variables $(v_i, u_i, d_i) \subset \I$.

**** Generator Input
Each generator has the tuple input of ($i, \I, \C$) where $i$ is the visit index, $\I_i$ is the tuple $\visit$
([[#sec:problem-description]]), that describes the set of visits generated by the route generation algorithm
([[#sec:route-gen]]), and $\C$ is the set that describes the availability for all chargers $q \in \mathcal{Q}$. In other
words, $\C$ defines the set of times when the chargers are not being utilized or are ``inactive''.

To derive $\C$, consider its inverse, $\C'$, which is the set of ``active'' time periods for each charger, $\C' =
\bigcup \{\C_q' : q \in \mathcal{Q}\}$ where $\C_q' \subset \C'$ describes the active times for charger $q$. Focusing on
an individual charger, consider $\C_q'$ before a schedule has been imposed upon it, $\C_q' \in \varnothing$. In other
words, no buses have been assigned to be charged over the time period of $[u_i, d_i]$. After the scheduling process is
complete, $\C_q'$ will have a set of active periods of the form $\C_q' \in \{[u_j, d_j]: j \in \mathcal{J}\}$ where
$\mathcal{J} \subset \mathcal{I}$. For $\C_q'$ to be of value, its compliment is to be found, $\C_q$.

To determine the inverse of $\C_q'$, begin by noting $\C_q' \bigcap \{[u_j, d_j] : j \in \mathcal{J}\} = \varnothing$, in
other words is said to be disjoint \cite{NaiveHalmos}. The inverse of a disjoint set can be found by the De Morgan Law
as shown in [[eq:demorgan]]. Using [[eq:demorgan]], the set of inactive periods can be written as $\C_q \equiv \bigcup \{[u_j,
d_j]': j \in \mathcal{J}\}$.

#+name: eq:demorgan
#+begin_export latex
\begin{equation}
\label{eq:demorgan}
(A \cap B)' = A' \cup B'
\end{equation}
#+end_export

**** Generator Output
The output, $x_i' \equiv (v_i, u_i, d_i) \subset \I_i$ defines tuple of the chosen queue, initial charge time, and
detach time from the generator, $(v_i, u_i, d_i)$. The nature of SA implies that the generators have a sense of
randomness. Because of that, some of the generators may have multiple choices for what $x_i'$ may be. Let the set of
candidates for the output be defined as $x_i' \in X_i'$.

*** Generators
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Note that to satisfy constraints, $B$ extra idle queues that provide no power to the bus. Because of
this, the set of queues is fully defined as $q \in \{1,..., Q, Q+1,..., Q+b\}$ where $Q$ is the total amount of chargers
and $b$ is the bus ID. The use case for this is for when a bus is not to be placed on a charger, it will be placed in
the queue, $v_i \in \{Q+1,..., Q+b\}$, which will satisfy the constraints above while allowing the bus to be "set aside"
while others charge.

**** New visit
:PROPERTIES:
:CUSTOM_ID: new-visit
:END:
The new visit generator describes the process of moving bus $b$ from the idle queue, $v_i \in \{Q+1,..., Q+b\}$ to a
valid charging queue, $v_i \in \{1,..., Q\}$. Line 2 initializes the set of solutions to the empty set. Line 3 loops
through each charger availability set and line 4 loops thorough each of the available ranges, denoted as $L$ and $U$ for
lower and upper free time. Line 5 checks if the range $[a_i, e_i] \subset [L, U]$, and line 6 adds it to the set of
candidates. Line 10 chooses picks a candidate soluition,$x_i' \subset X_i'$, with a discrete uniform distribution which
is denoted by $\mathcal{U}_{\{\cdot\}}$.

#+name: alg:new-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-visit}
\caption{New visit algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Visit}
    \KwIn{($\Sol$)}
    \KwOut{$x_i'$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{findFreeTime}{findFreeTime}

    \Begin
    {
        $X_i' \leftarrow \varnothing$ \tcc*{Begin with the empty set}

        \ForEach (\tcc*[f]{For set of availabile times for charger $q$}) {$\C_q \in \C$}
        {
            \ForEach (\tcc*[f]{For each inactive region in $\C_q$}) {$C \in \C_q$}
            {
                \If(\tcc*[f]{If there is time available in $C$}){\findFreeTime{C, ($a_i, e_i$)} $\not\in \varnothing$}
                {
                    $X_i' \cup x_i'$ \tcc*{Add $x_i'$ to the set of candidates}
                }
            }
        }
        \Return{$\mathcal{U}_{X_i'}$} \tcc*[f]{Return a random candidate}
    }
\end{algorithm}
#+end_export

The algorithm to find free time is defined in Algorithm [[alg:find-free-time]]. $L$ and $U$ are the lower and upper bound of
the time between scheduled times. The possible use cases are depicted in [[fig:find-free]].

#+name: fig:find-free
#+begin_export latex
\input{img/find-free.tex}
#+end_export

#+name: alg:find-free-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:find-free-time}
\caption{Find free time algorithm searches and returns the available time frames}
    \LinesNumbered
    \TitleOfAlgo{Find Free Time}
    \KwIn{$(L,U,a,e)$}
    \KwOut{$(u,d)$}

    \Begin
    {
        \If(\tcc*[f]{If $L < a < e < U]$ (\autoref{subfig:sandwich})}){$L \leq a$ and $U \geq e$}
        {
                u $\leftarrow$ $\mathcal{U}_{[a,e]}$\;
                d $\leftarrow$ $\mathcal{U}_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a < L < e < U$ (\autoref{subfig:all})}){$L > a$ and $U \geq e$}
        {
                u $\leftarrow$ $\mathcal{U}_{[L,e]}$\;
                d $\leftarrow$ $\mathcal{U}_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $L < a < U < e$ (\autoref{subfig:egu})}}){$L \leq a$ and $U < e$}
        {
                u $\leftarrow$ $\mathcal{U}_{[a,U]}$\;
                d $\leftarrow$ $\mathcal{U}_{[u,U]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a \leq u \leq d \leq L$ or $U \leq a \leq d \leq e$ (\autoref{subfig:invertsandwhich})}){$L > a$ and $U < e$}
        {
                u $\leftarrow$ $\mathcal{U}_{[a,L], [U,e]}$\;
                d $\leftarrow$ $\mathcal{U}_{[u,L], [u,e]}$\;
        }
        \Else(\tcc*[f]{Otherwise the bus cannot be scheduled in this time frame (\autoref{subfig:invalid})})
        {
                u $\leftarrow$ $\varnothing$\;
                d $\leftarrow$ $\varnothing$\;
        }

        \Return{(u,d)}
    }
\end{algorithm}
#+end_export

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because $a_i \leq u_i \leq d_i \leq e_i$ (arrival time
is less than initial charge time which is less than the detach time which is less than the time the bus exists the
station), there may be some room to move $u_i$ and $d_i$ within the window $[a_i, e_i]$. Two new values, $u_i$
and $d_i$ are selected with a uniform distribution to satisfy $a_i \leq u_i \leq d_i \leq e_i$.

#+name: alg:slide-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:slide-visit}
\caption{Slide Visit Algorithm}
    \LinesNumbered
    \TitleOfAlgo{Slide Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{$x_i'$: $(v,u,d)$}

    \Begin
    {
        $a \leftarrow$ route-data[$i$].$a$\;
        $e \leftarrow$ route-data[$i$].$e$\;

        $u \leftarrow$ $\mathcal{U}_{[a,e]}$\;
        $d \leftarrow$ $\mathcal{U}_{[u,e]}$\;

        \Return{(v,d)}
    }
\end{algorithm}
#+end_export

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
Similar to new visit, this generator moves a bus from one queue to another; however, the new charger generator moves a
bus from one charger queue to another, $v_i \in \{0,..,Q\}$. A new charger will be selected at random with a uniform
distribution.

#+name: alg:new-charger
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-charger}
\caption{New Charger Algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Charger}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{$x_i'$: $(v,u,d)$}

    \Begin
    {
       $a \leftarrow$ route-data[$i$].$a$\;
       $e \leftarrow$ route-data[$i$].$e$\;
       $v \leftarrow$ route-data[$i$].$v$\;
       valid-visit  $\leftarrow \varnothing$\;

       \For{$q\; \leftarrow 0$ \KwTo $Q$ and $q \neq v$}
       {
               \For{region $\leftarrow$ \KwTo q.free}
               {
                       \Union{valid-visit, \findFreeTime{region, (a,e)}}\;
               }
       }

       \Return{$\mathcal{U}_{[valid-visit[0],valid-visit[length(valid-visit)-1]]}$}
    }
\end{algorithm}
#+end_export

**** Remove
:PROPERTIES:
:CUSTOM_ID: sec:remove
:END:
The remove generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in
\{Q,...,Q+B\}\).

#+name:alg:remove
#+begin_export latex
\begin{algorithm}[H]
\label{alg:remove}
\caption{Remove algorithm}
    \LinesNumbered
    \TitleOfAlgo{Remove}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{$x_i'$: $(v,u,d)$}

    \Begin
    {

       $v \leftarrow Q+b$                \;
       $u \leftarrow$ route-data[$i$].$u$\;
       $d \leftarrow$ route-data[$i$].$d$\;

       \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

**** New Window
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
New window is a combination of the remove and then new visit generators ([[#sec:remove]] and [[#sec:new-visit]]). By this it is
meant that current scheduled tuple $(v_i, u_i, d_i)$ is removed and added back in as if it were a new visit.

#+name: alg:new-window
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-window}
\caption{New window algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Window}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{$x_i'$: $(v,u,d)$}

    \Begin
    {
        \SetKwFunction{NewVisit}{NewVisit}
        \SetKwFunction{Remove}{Remove}

         $v \leftarrow$ route-data[$i$].$v$\;
         $u \leftarrow$ route-data[$i$].$u$\;
         $d \leftarrow$ route-data[$i$].$d$\;
        $(v,u,d)$ = \Remove{$v,u,d$}\;
        $(v,u,d)$ = \NewVisit{$v,u,d$}\;

        \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: generator-wrappers
:END:
This section covers the algorithms utilized to select and execute different generation processes for the SA process. The
generator wrappers are the method immediately called by SA. Each wrapper utilizes the generators previously described
and returns either metadata about the bus routes or a new valid charger schedule.

**** Route Generation
:PROPERTIES:
:CUSTOM_ID: sec:route-gen
:END:
The objective of route generation is to create a set of metadata about bus routes given the information in
[[fig:routeyaml]]. Specifically, the objective is to generate $I$ routes for $B$ buses. Each visit will have an initial
charge (specified for first visit only), arrival time, departure time, final charge (minimum allowed charge specified
for finial visit only).

This is created by following the "GenerateSchedule" state in the state diagram found in [[fig:route]]. In essence the logic
is as follows: Generate $B$ random numbers that add up to $I$ visits (with a minimum amount of visits set for each bus).
For each bus and for each visit, set a departure time that is between the range [min_rest, max_rest] ([[fig:routeyaml]]),
set the next arrival time to be $j \cdot \frac{T}{\text{J}}$ where $j$ is the $j^{th}$ visit for bus $b$ and $J$ is the
total number of visits for bus $b$. Finally, calculate the amount of discharge from previous arrival to the departure
time.

#+name: alg:route-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:route-generation}
\caption{Route generation algorithm}
    \LinesNumbered
    \TitleOfAlgo{RouteGeneration}
    \KwIn{Route YAML metadata: (mdata)}
    \KwOut{Array of route events: (route-data)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{DepartureTime}{DepartureTime}
    \SetKwFunction{ArrivalTimeNew}{ArrivalTimeNew}
    \SetKwFunction{Discharge}{Discharge}
    \SetKwFunction{SortByArrival}{SortByArrival}
    \SetKwFunction{Feasible}{Feasible}

    \Begin
    {
        \While{\Not schedule-created}
        {
            arrival-new $\leftarrow$ 0.0\;
            arrival-old $\leftarrow$ 0.0\;
            departure-time $\leftarrow$ 0.0\;
            schedule-created $\leftarrow$ false\;

            \ForEach{b $\in$ B}
            {
                \ForEach{n $\in\; J_b$}
                {
                    arrival-old $\leftarrow$ arrival-new\;

                    \If{j = $J_b$}{final-visit = true\;}
                    \Else{final-visit = false\;}

                    departure-time $\leftarrow$ \DepartureTime{arrival-old, final-visit}\;
                    arrival-new $\leftarrow$ current-visit*$\frac{T}{J_b}$\;
                    discharge $\leftarrow$ discharge-rate*(next-arrival, depart-time)    \;
                    \Union{route-data, (arrival-old, departure-time, discharge)}\;
                }
            }

            schedule-created $\leftarrow$ \Feasible{route-data}\;
            \SortByArrival{route-data}\;
        }

    }
\end{algorithm}
#+end_export

Where =discharge-rate= is read from YAML data shown in [[fig:routeyaml]], the =Departure= algorithm is shown in Algorithm
[[alg:departure-time]], and the =Feasible= method is used to determine if the generated schedule is valid (conditions
covered in [[#sec:constraints]]). This is done by attempting to generate a schedule that is in the solution space. This is
further elaborated on later.

#+name: alg:departure-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:departure-time}
\caption{Departure time algorithm}
    \LinesNumbered
    \TitleOfAlgo{DepartureTime}
    \KwIn{Previous arrival and final visit flag: (arrival-old and final-visit)}
    \KwOut{Next departure time: (depart)}

    \Begin
    {
        \If{final-visit}
        {
            depart $\leftarrow$ T\;
        }
        \Else
        {
            depart $\leftarrow$ arrival-old + $\mathcal{U}_{[\text{min-rest},\text{max-rest}]}$\;
        }

        \Return{depart}
    }
\end{algorithm}
#+end_export

**** Schedule Generation
:PROPERTIES:
:CUSTOM_ID: schedule-generation
:END:
The objective of this generator is to generate a candidate solution to the given schedule. To generate a candidate
solution the generator is given the route schedule data that was previous generated. A bus is picked at random, $b \in
B$, then a random route is picked for bus $b$. The new arrival generator is then utilized. This process is repeated for
each visit. The state diagram is depicted in the state digram in [[fig:schedule]] and outlined in Algorithm
[[alg:schedule-generation]].

#+name: alg:schedule-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:schedule-generation}
\caption{Schedule generation algorithm}
    \LinesNumbered
    \TitleOfAlgo{ScheduleGeneration}
    \KwIn{Route data: (route-data)}
    \KwOut{Candidate charging schedule: (schedule)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        schedule $\leftarrow\; \varnothing$\;
        \For {i in I}
        {
            bus $\leftarrow\; \mathcal{U}_{[0,B]}$\;
            visit $\leftarrow\; \mathcal{U}_{[0,I]}$\;
            \Union{schedule,\NewVisit{(visit.a, visit.e)}}\;
        }
            \Return{schedule}
    }
\end{algorithm}
#+end_export

Where =schedule= is $\I = \{ (b_i, a_i, e_i, u_i, d_i, v_i, \eta_i): b_i \in B, a_i, e_i, u_i, d_i \in T, v_i \in Q\}$.

**** Perturb Schedule
:PROPERTIES:
:CUSTOM_ID: tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit a given solution \cite{Radosavljevic2018-jc}.
The method that will be employed to exploit the given solution is as follows: pick a bus, pick a visit, pick a
generator. This state diagram is depicted in [[fig:perturb]] and outlined in Algorithm [[alg:perturb-schedule]].

#+name: alg:perturb-schedule
#+begin_export latex
\begin{algorithm}[H]
\label{alg:perturb-schedule}
\caption{Perturb schedule algorithm}
    \LinesNumbered
    \TitleOfAlgo{PerturbSchedule}
    \KwIn{Schedule candidate solution: (schedule)}
    \KwOut{Perturbed schedule: (schedule)}

    \SetKwFunction{GeneratorCallback}{GeneratorCallback}

    \Begin
    {
        \For {i in I}
        {
            visit $\leftarrow\; \mathcal{U}_{[0,I]}$\;
            generator $\leftarrow\; \mathcal{U}_{[0,generator-count]}$\;
            schedule $\leftarrow$ \GeneratorCallback[generator]{(visit, route-data, charger-data)}\;
        }

        \Return{schedule}
    }
\end{algorithm}
#+end_export

* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: optimization-algorithm
:END:
This final section combines the generation algorithms and the optimization problem into a single algorithm. The
objective is to outline the SA process from start to finish. Algorithm [[alg:route-generation]] generates a set of bus
routes utilizing the route metadata in [[fig:routeyaml]]. The initial temperature and cooling schedule will be selected
prior to execution and passed into the SA optimization algorithm. A new candidate solution will be generated. The
candidate solution will be checked if it is feasible by using the equations from [[#sec:constraints]]. For each step in the
cooling schedule will have $K$ iterations to attempt to find a local maxima. Each perturbation to the system is then
compared to the current candidate solution. If the new candidate solution is better it is kept; however, if the
candidate solution is worse, the solution may still be kept with a calculated probability as described in
[[#sec:acceptance]]. This process is summarized in Algorithm [[alg:sa-pap]].

#+name: alg:sa-pap
#+begin_export latex
\begin{algorithm}[H]
\label{alg:sa-pap}
\caption{Simulated annealing approach to the position allocation problem}
    \LinesNumbered
    \TitleOfAlgo{SA PAP}
    \KwIn{Bus route metadata: (file-path)}
    \KwOut{Optimal charging schedule: (schedule)}

    \SetKwFunction{InitTemp}{InitTemp}
    \SetKwFunction{GetCoolingEquation}{GetCoolingEquation}
    \SetKwFunction{InSolutionSpace}{InSolutionSpace}
    \SetKwFunction{LoadYaml}{LoadYaml}
    \SetKwFunction{RouteGeneration}{RouteGeneration}
    \SetKwFunction{J}{J}
    \SetKwFunction{ScheduleGeneration}{ScheduleGeneration}
    \SetKwFunction{PerturbSchedule}{PerturbSchedule}

    \Begin
    {
        $\Tau_0\; \leftarrow$ \InitTemp{}\;
        $\Tau_{schedule}\; \leftarrow$ \GetCoolingEquation{}\;

        route-metadata $\leftarrow$ \LoadYaml{file-path}\;
        routes $\leftarrow$ \RouteGeneration{route-metadata}\;

        best-solution $\leftarrow v \in$ \ScheduleGeneration{routes}\;

        \ForEach{$\Tau \in \Tau_{schedule}(\Tau_0)$}
        {
            candidate-solution $\leftarrow$ \ScheduleGeneration{routes}\;

            \If{\InSolutionSpace{candidate-solution}}
            {
              \ForEach{$k \in K$}
              {
                del-sol $\leftarrow$ \J{candidate-solution} - \J{best-solution}\;

                \If{del-sol $\leq$ 0}
                {
                   best-solution $\leftarrow$ candidate-solution\;
                }
                \ElseIf{del-sol $\geq$ 0}
                {
                    best-solution $\leftarrow$ candidate-solution with probability $\exp$(del-sol$\tau_k$)\;
                }

                schedule $\leftarrow$ \PerturbSchedule{schedule}\;
            } % If
          }   % ForEach
        }     % If
    }
\end{algorithm}
#+end_export

\bibliographystyle{plain}
\bibliography{main}

#+name: fig:route
#+caption: Route generation state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/route_generation.png]]

#+name: fig:routeyaml
#+caption: Route YAML file with example data
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/route_yaml.png]]

#+name: fig:schedule
#+caption: Charge solution state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/charge_solution.png]]

#+name: fig:perturb
#+caption: Solution perturb state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.2\textwidth
[[file:img/charge_perturb.png]]


#  LocalWords:  SA
