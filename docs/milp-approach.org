#+TITLE: Bus Charging Schedule Simulated Annealing with MILP Constraints
#+DATE: \today
#+EMAIL: A01704744@usu.edu
#+LANGUAGE: en

# Custom commands
#+latex_header: \newcommand{\T}{\mathcal{T}}
#+latex_header: \newcommand{\Tau}{T}

This document outlines the simulated annealing (SA) approach to the bus
charging scheduling problem utilizing Mixed Integer Linear Programming (MILP) constraints as the method of determining
feasible charging schedules. The problem statement is as follows: given a set of routes for a fleet of Battery Electric
Buses (BEB), generate an optimal charging schedule to minimize:

- Consumption cost (amount of electricity used over a certain time)
- Demand cost (rate at which electricity is being used)

within the constraints that the buses have sufficient charge to complete the working day and do not have any delays in
their respective routes.

Simulated Annealing (SA) shall be introduced and utilized as a means of finding the global optima of the objective
function/MILP constraint formulation; however, there are other metaheuristic mechanisms similar to SA that may be
utilized.

* Simulated Annealing

SA is a local search (exploitation oriented) single-solution based (as compared to population based) metaheuristic
approach in which its main advantage is simply \cite{Gendreau2018-pw}. This model is named after its analogised process
where a crystalline solid is heated then allowed to cool very slowly until it achieves its most regular possible crystal
lattice configuration \cite{Henderson}. There are five key components to SA:

- Initial Temperature
- Cooling schedule (temperature function)
- Generation mechanism
- Acceptance criteria
- Local search iteration count (temperature change counter)

The initial temperature and cooling schedule are used to regulate the speed at which the solution attempts to converge
to the best known solution. When the temperature is high, SA encourages exploration. As it cools down (in accordance to
the cooling schedule), it begins to encourage local exploitation of the solution \cite{Rutenbar_1989; @Henderson}.

** Cooling Equation (Experimental)
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
There are three basic types of cooling equations as shown in \autoref{fig:cool}. A linear cooling schedule is defined by

\[ \Tau[n] = \Tauau[n-1] -\Delta_0 \]

with \(\Tau[0] = \Tau_0\) and \(\Delta_0 = 1/2\; C^\circ\) in \autoref{fig:cool}. A geometric cooling schedule is mostly used
in practice \cite{Keller_2019}. It is defined by

\[ \Tau[n] = \alpha \Tau[n-1] \]

where \(\alpha = 0.995\) in \autoref{fig:cool}. An Exponential cooling schedule is defined by the difference equation is
define as

\[ \Tau[n] = e^{\beta}\Tau[n-1] \]

where \(\beta\) = 0.01$ in \autoref{fig:cool}. The initial temperature, \(T_0\), in the case of \autoref{fig:cool}, is
set to \(500^\circ\; C\) and each schedule's final temperature is \(1\; C^\circ\).

#+caption: Cooling equations \label{fig:cool}
[[file:uml/cool-func.jpg]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
Acceptance criteria describes the method to accept or reject a given candidate solution. In SA, if a new candidate
solution is more fit than the currently stored solution it is always accepted as the new solution. However, within SA,
worse candidate solutions may be accepted as the new solution. The probability of accepting the candidate solution is
described by the function \(\exp(\frac{J(new-sol) - J(old-sol)}{\Tau})\) where \(J()\) is the objective functions
described in \autoref{sec:objective}.

** Decision variables
:PROPERTIES:
:CUSTOM_ID: decision-variables
:END:
Given a set of route metadata, initial charge at the start of the day, arrival times, discharge amounts, etc., a
charging solution must be generated. The key information required, known as the decision variables, are:

- \(\eta_i\): initial charges for each visit \(i\)
- \(d_i\) : detach time from the charger for each visit \(i\)
- \(p_dem\) : The demand cost for the working day
- \(u_i\) : Initial charge time of visit \(i\)
- \(s_i\) : Service time of the charger (\(s_i = d_i - u_d\))
- \(v_i\) : Assigned charger for visit \(i\)

In \autoref{sec:generators} all but \(p_dem\) and \(eta_i\) will be defined. \(p_dem\) will be defined in
\autoref{sec:objective}, and \(\eta_i\) will be defined in \autoref{sec:constraints}. All the variables are defined in
\autoref{tab:variables}.

\begin{table}[H]
   \caption{Notation}
   \label{tab:variables}
   \centering
   \begin{tabular}{l l l l}
           \toprule
           \textbf{Variable} & \textbf{Description}                                                  \\
           \toprule
           \multicolumn{1}{l}{Input values}                                                          \\
                   $B$        & Number of buses in use                                               \\
                   $I$        & Number of total visits                                               \\
                   $J(v,u,d)$ & Objective function                                                   \\
                   $K$        & Local search iteration amount                                        \\
                   $Q$        & Number of chargers                                                   \\
                   $\T$       & Time horizon                                                         \\
                   $\Tau$     & Temperature                                                          \\
           \hline
           \multicolumn{1}{l}{Input variables}                                                       \\
                   $\Delta_i$   & Discharge of visit over route $i$                                  \\
                   $\alpha_i$   & Initial charge percentage time for visit $i$                       \\
                   $\beta_i$    & Final charge percentage for bus $i$ at the end of the time horizon \\
                   $\delta_i$   & Discharge rate for vehicle $i$                                     \\
                   $\epsilon_q$ & Cost of using charger $q$                                          \\
                   $\kappa_i$   & Battery capacity for bus $i$                                       \\
                   $\xi_i$      & Value indicating the next index visit $i$ will arrive              \\
                   $a_i$        & Arrival time of visit $i$                                          \\
                   $b_i$        & ID for bus visit $i$                                               \\
                   $e_i$        & Time visit $i$ must exit the station                               \\
                   $k$          & Local search iteration $k$                                         \\
                   $m$          & Minimum charge percentage allowed for each visit                   \\
                   $r_q$        & Charge rate of charger $q$                                         \\
           \hline
           \multicolumn{1}{l}{Decision Variables}                                                    \\
                   $\eta_i$     & Initial charge for visit $i$                                       \\
                   $d_i$        & Detach time from charger for visit $i$                             \\
                   $p_{dem}(t)$ & Demand cost                                                        \\
                   $s_i$        & Amount of time spent on charger for visit $i$ (service time)       \\
                   $u_i$        & Initial charge time of visit $i$                                   \\
                   $v_i$        & Assigned queue for visit $i$                                       \\
                   \bottomrule
   \end{tabular}
\end{table}
** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
Generation mechanisms in SA are used to generate random solutions to propose to the optimizer. For the case of the bus
generation, five generation mechanism shall be used:

- New visit
- Slide visit
- New charger
- Remove
- New window

These generator mechanisms will in turn be utilized by three wrapper functions. One of them being to generate a set of
bus route data and the other two used to generate candidate solutions to the bus routes. These routines are defined as
follows:

- Route generation, \autoref{fig:route}, which utilizes route metadata
  as shown \autoref{fig:routeyaml}
- Schedule generation, \autoref{fig:schedule}
- Tweak schedule, \autoref{fig:tweak}

*** Generators
:PROPERTIES:
:CUSTOM_ID: generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Note that to satisfy constraints, \(B\) extra dummy chargers with a power of \(0\; KW\) will be added
to the array of valid chargers. When a bus is not to be placed on a charger, it will be placed in the queue \(v_i \in
\{Q,...,Q+b\}\). Where \(Q\) is the total amount of chargers and \(b\) is the bus id.

**** New visit
:PROPERTIES:
:CUSTOM_ID: new-visit
:END:
The new visit generator describes the process of moving bus \(b\) from the idle queue, \(v_i \in \{Q,..,Q+b\}\) to a
valid charging queue, \(v_i \in \{0,..,Q\}\). A list of tuples describing valid time, \(u_i\) and \(d_i\), for each
charger will be listed and randomly selected using a uniform distribution. The algorithm is defined in Algorithm
\autoref{alg:new-visit}.

\begin{algorithm}[H]
\label{alg:new-visit}
\caption{New visit algorithm}
    \TitleOfAlgo{New Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue and valid time region: $(v,u,d)$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{findFreeTime}{findFreeTime}

    \Begin
    {
        $a$          $\leftarrow$ route-data[$i$].$a$\;
        $e$          $\leftarrow$ route-data[$i$].$e$\;
        valid-visit  $\leftarrow \emptyset$      \;

        \For{q $\leftarrow 0$ \KwTo Q}
        {
                \For{free-region $ \leftarrow $ \KwTo charger-data[$q$]}
                {
                        \Union{valid-visit, ($q$,\findFreeTime{free-region, ($a$,$e$)})}\;
                }
        }

        \Return{$\mathbb{U}_{[valid-visit[0],valid-visit[length(valid-visit)-1]]}$}
    }
\end{algorithm}

Where \(\mathbb{U}_[a,b]\) is the continuous uniform distribution of \(a\) and \(b\), =route-data= is the data generated
in =RouteGeneration= (described in \autoref{sec:route-gen}), and =charger-data= are the time intervals allocated to
buses. The algorithm to find free time is defined in Algorithm \autoref{alg:find-free-time}. The cases are depicted in
\autoref{fig:find-free}.

\begin{figure}
\centering
\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $L \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (2.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (4.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq U$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (1.5,0);
        \coordinate (C) at (2.0,0);
        \coordinate (D) at (3.5,0);
        \coordinate (E) at (3.0,0);
        \coordinate (F) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);
        \draw[blue] (E) -- (F);

        \node[circle,fill=blue,radius=0.15]                     at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (E) {};
        \node[circle,fill=blue,radius=0.15]                     at (F) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid position: $a_1 \leq u_1 \leq d_1 \leq L$ or $U \leq u_1 \leq d_1 \leq e_1$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (1.5,0);
        \coordinate (B) at (3.5,0);
        \coordinate (C) at (0.0,0);
        \coordinate (D) at (5.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $a_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $e_1$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\par\bigskip

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0.0,0);
        \coordinate (B) at (5.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (3.5,0);

        \draw[blue] (A) -- (B);
        \draw[red]  (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $L$]   at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $U$]   at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_1$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_1$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\caption{Outlines the different cases that requested time and charger allocated time can overlap}
\label{fig:find-free}
\end{figure}
\begin{algorithm}[H]
\label{alg:find-free-time}
\caption{Find free time algorithm searches and returns the available time frames}
    \TitleOfAlgo{Find Free Time}
    \KwIn{Lower and upper bound of available time and arrival and departure time for bus: $(L,U,a,e)$}
    \KwOut{Tuple of initial and final charge times: $(u,d)$}

    \Begin
    {
        \If{$L \leq a$ and $U \geq e$}{
                u $\leftarrow$ $\mathbb{U}_{[a,e]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,e]}$\;
        }
        \ElseIf{$L > a$ and $U \geq e$}{
                u $\leftarrow$ $\mathbb{U}_{[L,e]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,e]}$\;
        }
        \ElseIf{$L \leq a$ and $U < e$}{
                u $\leftarrow$ $\mathbb{U}_{[a,U]}$\;
                d $\leftarrow$ $\mathbb{U}_{[u,U]}$\;
        }
        \Else($L > a$ and $U < e$){
                u $\leftarrow$ $\emptyset$\;
                d $\leftarrow$ $\mathbb{U}_{[u,U]}$\;
        }

        \Return{(u,d)}
    }
\end{algorithm}

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because \(a_i \leq u_i \leq d_i \leq e_i\) (arrival time
is less than initial charge time which is less than the detatch time which is less than the time the bus exists the
station), there may be some room to move \(u_i\) and \(d_i\) within the window \([a_i, e_i]\). Two new values, \(u_i\)
and \(d_i\) are are selected with a uniform distribution to satisfy \(a_i \leq u_i \leq d_i \leq e_i\).

\begin{algorithm}[H]
\label{alg:slide-visit}
\caption{Slide Visit Algorithm}
    \TitleOfAlgo{Slide Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
        $a \leftarrow$ route-data[$i$].$a$\;
        $e \leftarrow$ route-data[$i$].$e$\;
        $u \leftarrow$ $\mathbb{U}_{[a,e]}$\;
        $d \leftarrow$ $\mathbb{U}_{[u,e]}$\;

        \Return{(v,d)}
    }
\end{algorithm}

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
Similar to new visit, this generator moves a bus from one queue to another; however, the new charger generator moves a
bus from one charger queue to another, \(v_i \in \{0,..,Q\}\). A new charger will be selected at random with a uniform
distribution.

\begin{algorithm}[H]
\label{alg:new-charger}
\caption{New Charger Algorithm}
    \TitleOfAlgo{New Charger}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
       $a \leftarrow$ route-data[$i$].$a$\;
       $e \leftarrow$ route-data[$i$].$e$\;
       $v \leftarrow$ route-data[$i$].$v$\;
       valid-visit  $\leftarrow \emptyset$\;

       \For{$q\; \leftarrow 0$ \KwTo $Q$ and $q \neq v$}
       {
               \For{free-region $\leftarrow$ \KwTo q.free}
               {
                       \Union{valid-visit, \findFreeTime{free-region, (a,e)}}\;
               }
       }

       \Return{$\mathbb{U}_{[valid-visit[0],valid-visit[length(valid-visit)-1]]}$}
    }
\end{algorithm}

**** Remove
:PROPERTIES:
:CUSTOM_ID: sec:remove
:END:
The remove generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in
\{Q,...,Q+B\}\).

\begin{algorithm}[H]
\label{alg:remove}
\caption{Remove algorithm}
    \TitleOfAlgo{New Visit}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, time region: $(v,u,d)$}

    \Begin
    {

       $v \leftarrow Q+b$                \;
       $u \leftarrow$ route-data[$i$].$u$\;
       $d \leftarrow$ route-data[$i$].$d$\;

       \Return{$(v,u,d)$}
    }
\end{algorithm}
**** New window
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
New window is a combination of the remove and then new visit generators
(\autoref{sec:remove} and \autoref{sec:new-visit}).

\begin{algorithm}[H]
\label{alg:new-window}
\caption{New window algorithm}
    \TitleOfAlgo{New Window}
    \KwIn{Visit index, route data, Charger data: ($i$, route-data, charger-data)}
    \KwOut{Tuple of queue, valid time region: $(v,u,d)$}

    \Begin
    {
        \SetKwFunction{NewVisit}{NewVisit}
        \SetKwFunction{Remove}{Remove}

         $v \leftarrow$ route-data[$i$].$v$\;
         $u \leftarrow$ route-data[$i$].$u$\;
         $d \leftarrow$ route-data[$i$].$d$\;
        $(v,u,d)$ = \Remove{$v,u,d$}\;
        $(v,u,d)$ = \NewVisit{$v,u,d$}\;

        \Return{$(v,u,d)$}
    }
\end{algorithm}

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: generator-wrappers
:END:
This section covers the algorithms utilized to select and execute
different generation processes for the SA process.

**** Route Generation
:PROPERTIES:
:CUSTOM_ID: sec:route-gen
:END:
The objective of route generation is to create a set of metadata about
bus routes given the information in \autoref{fig:routeyaml}.
Specifically, the objective is to generate \(I\) routes for \(B\) buses.
Each visit will have

- Initial charge (for first visit only)
- Arrival time
- Departure time
- Final charge (for finial visit only)

This is created by following the "GenerateSchedule" state in the state
diagram found ind \autoref{fig:route}. In essence the logic is as
follows: Generate \(B\) random numbers that add up to \(I\) visits (with
a minimum amount of visits set for each bus). For each bus and for each
visit, set a departure time that is between the range [min_rest,
max_rest] (\autoref{fig:routeyaml}), set the next arrival time to be
\(j \cdot \frac{T}{\text{number-of-bus-visits}}\) where \(j\) is the
\(j^{th}\) visit for bus \(b\). Finally, calculate the amount of
discharge from previous arrival to the departure time.

\begin{algorithm}[H]
\label{alg:route-generation}
\caption{Route generation algorithm}
    \TitleOfAlgo{RouteGeneration}
    \KwIn{Route YAML metadata path: (path)}
    \KwOut{Array of route events: (route-data)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NumBusVisits}{NumBusVisits}
    \SetKwFunction{DepartureTime}{DepartureTime}
    \SetKwFunction{ArrivalTimeNew}{ArrivalTimeNew}
    \SetKwFunction{Discharge}{Discharge}
    \SetKwFunction{SortByArrival}{SortByArrival}
    \SetKwFunction{Feasible}{Feasible}

    \Begin
    {
        \While{!schedule-created}
        {
            arrival-new $\leftarrow$ 0.0\;
            arrival-old $\leftarrow$ 0.0\;
            departure-time $\leftarrow$ 0.0\;
            num-visit $\leftarrow$ \NumBusVisits{B}\;
            schedule-created $\leftarrow$ false\;

            \For{$b \in B$}
            {
                \For{$n \in num-visit[b]$}
                {
                    arrival-old $\leftarrow$ arrival-new\;

                    \If{$j = num-visit[b]$}{final-visit = true\;}
                    \Else{final-visit = false\;}

                    departure-time $\leftarrow$ \DepartureTime{arrival-old, final-visit}\;
                    arrival-new $\leftarrow$ current-visit*$\frac{T}{total-visit-count}$\;
                    discharge $\leftarrow$ discharge-rate*(next-arrival-depart-time)    \;
                    \Union{route-data, (arrival-old, departure-time, discharge)}\;
                }
            }

            schedule-created $\leftarrow$ \Feasible{route-data}\;
            \SortByArrival{route-data}\;
        }

    }
\end{algorithm}

#+begin_html
  <!-- Departure Time -->
#+end_html

\begin{algorithm}[H]
\label{alg:departure-time}
\caption{Departure time algorithm}
    \TitleOfAlgo{DepartureTime}
    \KwIn{Previous arrival and final visit flag: (arrival-old and final-visit)}
    \KwOut{Next departure time: (depart)}

    \Begin
    {
        \If{final-visit}
        {
            depart $\leftarrow$ T\;
        }
        \Else
        {
            depart $\leftarrow$ arrival-old + $\mathbb{U}_{[min-rest,max-rest]}$\;
        }

        \Return{depart}
    }
\end{algorithm}
Where =discharge-rate= is read from YAML data shown in
\autoref{fig:routeyaml}, the =Feasible= method is used to determine if
the generated schedule is valid (conditions covered in
\autoref{sec:constraints}).

**** Schedule Generation
:PROPERTIES:
:CUSTOM_ID: schedule-generation
:END:
The objective of this generator is to generate a candidate solution to
the given schedule. To generate a candidate solution the generator is
given the route schedule data that was previous generated. A bus is
picked at random, \(b \in B\), then a random route is picked for bus
\(b\). The new arrival generator is then utilized. This process is
repeated for each visit. The state diagram is depicted in the state
digram in \autoref{fig:schedule} and outlined in Algorithm
\autoref{alg:schedule-generation}.

\begin{algorithm}[H]
\label{alg:schedule-generation}
\caption{Schedule generation algorithm}
    \TitleOfAlgo{ScheduleGeneration}
    \KwIn{Route data: (route-data)}
    \KwOut{Candidate charging schedule: (schedule)}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        schedule $\leftarrow\; \emptyset$\;
        \For {i in I}
        {
            bus $\leftarrow\; \mathbb{U}_{[0,B]}$\;
            visit $\leftarrow\; \mathbb{U}_{[0,total-visit-count]}$\;
            \Union{schedule,\NewVisit{(visit.a, visit.e)}}\;
        }
            \Return{schedule}
    }
\end{algorithm}
**** Tweak Schedule
:PROPERTIES:
:CUSTOM_ID: tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit
a given solution \cite{radosavljevic2018metaheuristic}. The method that
will be employed to exploit the given solution is as follows: pick a
bus, pick a visit, pick a generator. This state diagram is depicted in
\autoref{fig:tweak} and outlined in Algorithm
\autoref{alg:tweak-schedule}.

\begin{algorithm}[H]
\label{alg:tweak-schedule}
\caption{Tweak schedule algorithm}
    \TitleOfAlgo{TweakSchedule}
    \KwIn{Schedule candidate solution: (schedule)}
    \KwOut{Perturbed schedule: (schedule)}

    \SetKwFunction{GeneratorCallback}{GeneratorCallback}

    \Begin
    {
        \For {i in I}
        {
            bus $\leftarrow\; \mathbb{U}_{[0,B]}$\;
            visit $\leftarrow\; \mathbb{U}_{[0,total-visit-count]}$\;
            generator $\leftarrow\; \mathbb{U}_{[0,generator-count]}$\;
            schedule $\leftarrow$ \GeneratorCallback[generator]{(i, route-data, charger-data)}\;
        }

        \Return{schedule}
    }
\end{algorithm}
* Optimization Problem
:PROPERTIES:
:CUSTOM_ID: optimization-problem
:END:
This sections discusses and formulates the objective functions as well
as the MILP constraints. The objective functions are required to allow
comparisons between candidate solutions. The constraints ensure that
candidate solutions are in the feasible region.

** Objective Function
:PROPERTIES:
:CUSTOM_ID: sec:objective
:END:
Let \(J\) represent the objective function. The objective function has
four main considerations:

- Charger assignment
- Demand cost
- Consumption cost
- Sufficient charge

Suppose the objective function is of the form
\(J = AC(u, d, v) + PC(u, d, v)\). \(AC(u, d, v)\) is the assignment
cost, and \(PC(u, d, v)\) is the power usage cost. The assignment cost
can be represented as:

\[
AC(u,d,v) = \sum_{i=1}^I UsageCost(v_i, u_i, d_i) + ChargePenalty(\eta_i)
\]

Where \(v_i\) is the charger index, \(u_i\) is the initial charge time,
and \(d_i\) is the detach time for visit \(i\). The function
\(UsageCost(v,u,d)\) returns the cost of using charger \(q\) multiplied
by the usage time as shown in Algorithm \autoref{alg:usage-cost} and
\(\eta_i\) is the initial charge for visit \(i\). The
\(ChargePenalty(\eta_i)\) method exponentially punishes the candidate
solution if the initial charge for a specified visit \(i\) is not above
a given threshold as described in Algorithm
\autoref{alg:charge-penalty}.

\begin{algorithm}[H]
\label{alg:usage-cost}
\caption{Method describing the calculation for the cost of usage for charger $q$.}
    \TitleOfAlgo{UsageCost}
    \KwIn{Charger assignment, start charge time, end charge time: (v, u, i)}
    \KwOut{Cost of use of charger}

    \Begin
    {
        \Return{$\epsilon_q[v_i](d_i - u_i)$}
    }
\end{algorithm}
\begin{algorithm}[H]
\label{alg:charge-penalty}
\caption{Method describing the calculation for the penalty of buses not meeting the required charge threshold.}
    \TitleOfAlgo{ChargePenalty}
    \KwIn{Initial charge for visit $i$: $\eta_i$}
    \KwOut{Penalty}

    \Begin
    {
        penalty $\leftarrow$ 0\;

        \If{$m \kappa_i \geq \eta_{\xi_i}$}
        {
            penalty $\leftarrow\; exp(m - \eta_i)$\;
        }

        \Return{penalty}
    }
\end{algorithm}
Where \(m\) is the minimum charge percentage allowed at each visit and
\(\kappa_i\) is the battery capacity.

The power cost can begin to be defined with the consumption cost:

\[
PC(u,d,v) = DemandCost(schedule) + \sum_{i=1}^I  ConsumptionCost(v_i, u_i, d_i)
\]

where \(ConsumptionCost(v_i, u_i, d_i)\) returns the energy in \(KWH\)
given the charger index \(v_i\) and time spent on the charger \(d_i\) as
shown in Algorithm \autoref{alg:consumption-cost}.

\begin{algorithm}[H]
\label{alg:consumption-cost}
\caption{Method describing the consumption cost for a single visit}
    \TitleOfAlgo{ConsumptionCost}
    \KwIn{Charger assignment, start charge time, end charge time: (v, u, i)}
    \KwOut{Consumption cost}

    \Begin
    {
        \Return{$r[v_i](d_i - u_i)$}
    }
\end{algorithm}
Peak 15 should also be taken into consideration. Peak 15 is defined as:

\[
p_{15}(t) = 1/15 \int_{t-15}^{t} p(\tau) d\tau
\]

which represents the energy used over the last 15 minutes. Because worst
case must be assumed to always ensure enough power is supplied

\[
p_{max}(t) = \text{max}_{\tau\in [0,t]}p_{15}(\tau)
\]

Which retains the largest \(p_{15}\) found. The demand charge is then
determined by

\[
p_{dem}(t) = \text{max}(p_{fix},p_{max}(t))s_r
\]

where \(s_r\) is the demand rate. Which, again, retains the largest
\(p_{15}\) value with a starting, fixed value of \(p_{fix}\). To
calculate this numerically, an integration algorithm is required to
iteratively calculate the \(p_{15}(t)\). In turn, \(p_{dem}(T)\) can be
defined. This process is defined in Algorithm \autoref{alg:demand-cost}.

\begin{algorithm}[H]
\label{alg:demand-cost}
\caption{Algorithm to calculate the demand cost.}
    \TitleOfAlgo{DemandCost}
    \KwIn{Candidate solution: (schedule)}
    \KwOut{Demand cost: (p-dem)}

    \SetKwFunction{Integrate}{Integrate}
    \SetKwFunction{Union}{Union}

    \Begin
    {
        p15 $\leftarrow\; \emptyset$\;

        \For{dt $\leftarrow 0$ \KwTo T}
        {
            \Union{p15, \Integrate{schedule,(dt,dt+15)}}
        }

        p-old $\leftarrow$ p-new $\leftarrow$ p-dem $\leftarrow$ p-fix\;

        \ForEach{element p in p15}
        {
            p-old $\leftarrow$ p-new\;
            p-new $\leftarrow$ p\;

            \If{p-new > p-old}
            {
                p-dem $\leftarrow$ p-new\;
                p-old $\leftarrow$ p-new\;
            }
        }

        \Return{p-dem}
    }
\end{algorithm}
From this we can write:

\[
PC(u,d,v) = DemandCost(schedule) + \sum_{i=1}^I ConsumptionCost(v_i, u_i, d_i)
\]

** Constraints
:PROPERTIES:
:CUSTOM_ID: sec:constraints
:END:
Now that a method of calculating the fitness of a schedule has been
established, a method for determining the feasibility of a schedule must
be established. Feasible schedules require

- No overlap in time
- No overlap in space
- Bus receives enough charge
- Bus is not overcharged
- Departs on time

These set of requirements can be summarized by the constraints that
follow:

| (u_i \geq d_j \text{ or } u_j \geq d_i) \text{ and } v_i = v_j           | Valid queue position/time                                                       |
| \Delta_i = \delta_i(a_{\xi_i} - d_i)                                     | Calculate discharge of bus during route                                         |
| \eta_{\xi_i} = \eta_i + \text{ConsumptionCost}(v_i, a_i, e_i) - \Delta_i | Charge constraint                                                               |
| \kappa_i \geq \eta_i + \text{ConsumptionCost}(v_i, a_i, e_i)             | Ensure the bus is not charged over its maximum capacity                         |
| a_i \leq u_i \leq (T-s_i)                                                | Arrival time < initial charge time < maximum initial charge time                |
| d_i \leq e_i                                                             | Detach time should be less than or equal to departure                           |
| s_i = d_i - u_i                                                          | Time spent on charger is equal to the difference of the attach and detach times |

Where the valid queue position/time constraint is as defined in
\cite{tutorials_point} and depicted in \autoref{fig:valid-queue}. Also
note that the \(\eta\) constraints can only be verified /after/ the
schedule has been generated as the initial charge for each visit is
based from the previous charger selection and charge time.

\begin{figure}
\centering
\begin{subfigure}{\textwidth}
    \centering
    \caption{Valid time position: $u_1 \ngeq d_2$ or $u_2 \geq d_2$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (2,0);
        \coordinate (C) at (2.5,0);
        \coordinate (D) at (4.5,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position: $u_1 \ngeq d_2$ or $u_2 \ngeq d_1$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (3.5,0);
        \coordinate (C) at (1.5,0);
        \coordinate (D) at (4.5,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\begin{subfigure}{\textwidth}
    \centering
    \caption{Invalid position: $u_1 \ngeq d_2$ or $u_2 \ngeq d_1$ and $v_1 = v_2$}
    \begin{tikzpicture}[scale=2]
        \coordinate (A) at (0,0);
        \coordinate (B) at (4.5,0);
        \coordinate (C) at (1.0,0);
        \coordinate (D) at (3.0,0);

        \draw[blue] (A) -- (B);
        \draw[red] (C) -- (D);

        \node[circle,fill=blue,radius=0.15,label=above : $u_1$] at (A) {};
        \node[circle,fill=blue,radius=0.15,label=above : $d_1$] at (B) {};
        \node[circle,fill=red,radius=0.15,label=above  : $u_2$] at (C) {};
        \node[circle,fill=red,radius=0.15,label=above  : $d_2$] at (D) {};
    \end{tikzpicture}
\end{subfigure}

\caption{Set of possible collisions between two buses in the same queue.}
\label{fig:valid-queue}

\end{figure}

* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: optimization-algorithm
:END:
This final section combines the generation algorithms and the
optimization problem into a single algorithm. The objective is to
outline the SA process from start to finish. Algorithm
\autoref{alg:route-generation} generates a set of bus routes utilizing
the route metadata in \autoref{fig:routeyaml}. The initial temperature
and cooling schedule will be selected and passed into the SA
optimization algorithm. A new candidate solution will be generated. For
each step in the cooling schedule will have \(K\) iterations to attempt
to find a local maxima. Each perturbation to the system is then compared
to the current candidate solution. If the new candidate solution is
better it is kept; however, if the candidate solution is worse, the
solution may still be kept with a probability
\(\exp(\text{del-sol}/\Tau)\) as described in \autoref{sec:acceptance}.
This process is summarized in Algorithm \autoref{alg:sa-pap}.

\begin{algorithm}[H]
\label{alg:sa-pap}
\caption{Simulated annealing approach to the position allocation problem}
    \TitleOfAlgo{SA PAP}
    \KwIn{Bus route metadata: (file-path)}
    \KwOut{Optimal charging schedule: (schedule)}

    \SetKwFunction{InitTemp}{InitTemp}
    \SetKwFunction{GetCoolSchedule}{GetCoolSchedule}
    \SetKwFunction{LoadYaml}{LoadYaml}
    \SetKwFunction{RouteGeneration}{RouteGeneration}
    \SetKwFunction{J}{J}
    \SetKwFunction{ScheduleGeneration}{ScheduleGeneration}
    \SetKwFunction{TweakSchedule}{TweakSchedule}

    \Begin
    {
        $\Tau_0$ $\leftarrow$ \InitTemp{}\;
        $\Tau_{schedule}$ $\leftarrow$ \GetCoolSchedule{}\;

        route-metadata $\leftarrow$ \LoadYaml{file-path}\;
        routes $\leftarrow$ \RouteGeneration{route-metadata}\;

        best-solution $\leftarrow$ v \in \ScheduleGeneration{routes}\;

        \ForEach{$\Tau \in \Tau_{schedule}(\Tau_0)$}
        {
            candidate-solution $\leftarrow$ \ScheduleGeneration{routes}\;

            \ForEach{$k \in K$}
            {
                del-sol $\leftarrow$ \J{candidate-solution} - \J{best-solution}\;

                \If{del-sol $\leq$ 0}
                {
                    best-solution $\leftarrow$ candidate-solution
                }
                \ElseIf{del-sol $\geq$ 0}
                {
                    best-solution $\leftarrow$ candidate-solution with probability $\exp$(del-sol$/\tau_k)$
                }

                schedule $\leftarrow$ \TweakSchedule{schedule}
            }
        }
    }
\end{algorithm}

\bibliographystyle{plain}
\bibliography{main}

#+caption: Route generation state diagram\label{fig:route}
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/route_generation.png]]

#+caption: Route YAML file with example data\label{fig:routeyaml}
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/route_yaml.png]]

#+caption: Charge solution state diagram \label{fig:schedule}
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:uml/charge_solution.png]]

#+caption: Solution tweak state diagram \label{fig:tweak}
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.2\textwidth
[[file:uml/charge_tweak.png]]
