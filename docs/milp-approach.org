#+TITLE: Bus Charging Schedule Simulated Annealing with MILP Constraints
#+DATE: \today
#+EMAIL: A01704744@usu.edu
#+LANGUAGE: en

# =========================================================================================================================
# Org LaTeX options
#+OPTIONS: tex:t
#+OPTIONS: ':t
#+STARTUP: latexpreview

# =========================================================================================================================
# LaTeX packages
#+LATEX_CLASS: article
#+latex_header: \usepackage{lipsum}                         % Dummy filler text
#+latex_header: \usepackage{amsfonts}                       % Cool math fonts
#+latex_header: \setlength\parindent{0pt}                   % No indent for paragraphs

# =========================================================================================================================
# `autoref' formatting
#+latex_header: \renewcommand*{\sectionautorefname}{Section}
#+latex_header: \renewcommand*{\subsectionautorefname}{Subsection}
#+latex_header: \renewcommand*{\subsubsectionautorefname}{Subsubsection}
#+latex_header: \renewcommand*{\paragraphautorefname}{Paragraph}

# =========================================================================================================================
# Custom `Algoritm2e' commands
#+latex_header: \newcommand{\Or}{\textbf{ or }}
#+latex_header: \renewcommand*{\And}{\textbf{ and }}

# =========================================================================================================================
# Custom commands
#+latex_header: \newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{gray}{#1}}

#+latex_header: \newcommand{\T}{\mathcal{T}}                % To make it clear the difference
#+latex_header: \newcommand{\Tau}{T}                        % between Tau and T
#+latex_header: \newcommand{\AC}{AC(u, d, v, \eta)}         % Set the parameters for AC once
#+latex_header: \newcommand{\PC}{PC(u, d, v)}               % Set the parameters for PC once
#+latex_header: \newcommand{\ACi}{AC(u_i, d_i, v_i, \eta_i)}% Set the parameters for AC once
#+latex_header: \newcommand{\PCi}{PC(u_i, d_i, v_i)}        % Set the parameters for PC once
#+latex_header: \newcommand{\Not}{\textbf{not }}            % Custom `not' operator
#+latex_header: \newcommand{\visit}{(b_i, a_i, e_i, u_i, d_i, v_i, \eta_i, \xi_i)}
                                                            # Single visit tuple
#+latex_header: \newcommand{\I}{\mathbb{I}}                 % Set of visit tuples
#+latex_header: \newcommand{\C}{\mathbb{C}}                 % Charger availability information
#+latex_header: \newcommand{\U}{\mathcal{U}}                % Uniform distribution
#+latex_header: \newcommand{\Sol}{\mathbb{S}}               % A shorthand for visit tuple
#+latex_header: \newcommand{\M}{\mathbb{M}}                 % A shorthand for the metadata
#+latex_header: \newcommand{\Hd}{\mathbb{H}}                % Set of discrete times

#+latex_header: \newcommand{\Iset}{\mathcal{I}}             % Set of visits 1-I
#+latex_header: \newcommand{\Isetinit}{\mathcal{I}_0}       % Set of visits inital visits
#+latex_header: \newcommand{\Isetfinal}{\mathcal{I}_f}      % Set of visits final visits
#+latex_header: \newcommand{\Bset}{\mathcal{B}}             % Set of visits 1-B
#+latex_header: \newcommand{\Qset}{\mathcal{Q}}             % Set of visits 1-Q
#+latex_header: \newcommand{\Jset}{\mathcal{J}}             % Set of visits 1-J
#+latex_header: \newcommand{\Hset}{\mathcal{H}}             % Set of visits 1-H

# =========================================================================================================================
# More document configuration
#+begin_export latex
\parskip 3mm                                % Set the vetical space between paragraphs
\let\ref\autoref                            % Redifine `\ref` as `\autoref` because lazy
\SetCommentSty{mycommfont}                  % Set the comment color
#+end_export

# =========================================================================================================================
# Document

* Introduction
:PROPERTIES:
:CUSTOM_ID: sec:introduction
:END:
This document outlines the simulated annealing (SA) approach to the bus charging scheduling problem utilizing Mixed
Integer Linear Programming (MILP) constraints as the method of determining feasible charging schedules. The problem
statement is as follows: given a set of routes for a fleet of Battery Electric Buses (BEB) and a set of fast and slow
chargers, generate an optimal charging schedule to minimize the consumption cost (amount of electricity used over a
certain time) and the demand cost (rate at which electricity is being used) within the constraints that the buses must
maintain sufficient charge to complete the working day and do not have any delays in their respective routes.

Simulated Annealing (SA) shall be introduced and utilized as a means of finding optimizing. The SA algorithm
shall be constrained by a set of Mixed Integer Linear Program (MILP) constraints derived from the Position Allocation
Problem (PAP). These constraints are set in place to ensure validity of the proposed charging schedules. A set of
objective functions describing consumption cost and demand cost, as stated above, shall be minimized to reduce power
consumption and total cost of using the BEBs.

* Problem Description
:PROPERTIES:
:CUSTOM_ID: sec:problem-description
:END:
It is assumed that there are a total of $I$ visits to the station by $B$ buses. There are a total of $Q$ queues for the
bus at the station. Given a set of bus arrivals to a charging station $i \in \{1,..., I\} = \Iset \subset \mathcal{Z}$
with a set of chargers to be queued $q \in \{1,..., Q\} = \Qset \subset \mathcal{Z}$ where the bus is indicated by an
identification number $b \in \{1,..., B\} = \Bset \subset \mathcal{Z}$. Each bus arrival, $i$, can be represented by the
tuple: $\visit$, in which the ordered elements denote the bus identification number, $b_i$, arrival time to the station,
$a_i$, departure time from the station, $e_i$, time to start charging, $u_i$, time to stop charging, $d_i$, the charger
queue for the bus to be placed into, $v_i$, and the initial State Of Charge (SOC), $\eta_i$.

It is assumed that each visit occurs over the time horizon $T = \{ t : t_0 \le t \le t_f \}$. The set of all arrivals is
represented by the set $\I = \{\forall i \in \Iset \; \visit: b_i, \xi_i \in \Bset, a_i, e_i, u_i, d_i \in T, v_i \in
\Qset \}$. The concept of "arrivals" is derived from the PAP \cite{Qarebagh2019}. This idea of arrivals is useful in the
sense that it is easy to describe the state of any arbitrary arrival; however, although a bus may revisit the station
multiple times, the model assumes that each arrival is unique (i.e. no two bus arrives twice) therefore a system must be
put in place to track each bus over each arrival. That is why a bus identifier is placed in the tuple, and in that way
each bus can be tracked over each arrival.

For each arrival a bus must be placed in a singular queue, $v_i \in Q$. The charger $q$ is assumed to be either a fast
or slow charger or no charger at all. The bus is only allowed to visit one queue per visit. The amount of time the bus
is allowed to charge is dictated by the scheduled arrival time and required departure time, $[a_i, e_i]$. Although a bus
must be placed in a queue, if a bus does not require much charge, or none at all, partial charges, or no charging, is
allowed. It is not allowed for the bus to charge over its battery capacity limit. The battery charging rate is modeled
as linear, which remains accurate up to about an SOC of 80% charge \cite{Li2016}.

Each bus arrival, with the exception of the last arrival for each bus, has a paired "route" that the bus must perform.
This route, as one would expect, causes the bus to discharge by some certain amount. This paper assumes an average
discharge over a period of time where an estimated discharge is calculated for each route, $\Delta_i$. The charge
supplied while at the station is required to supply enough charge for each route (battery charge does not deplete to
zero) with an additional battery capacity percentage, $m$, acting as a safety factor.

The scheduler's task shall be to schedule the set of arrivals $\I$ to fulfill the minimum charge requirements
over the time horizon $T$ as well as minimize the demand cost as well as minimize over the consumption cost. The
objective function and constraints are discussed in further detail in section [[#sec:objective-function]].

* Optimization Problem
:PROPERTIES:
:CUSTOM_ID: optimization-problem
:END:
This sections introduces the problem in the form of the objective function as well MILP constraints. The objective
function is required to allow comparisons between candidate solutions. In the context of this formulation, the objective
function is broken down into two major components as alluded in the introduction: consumption cost and demand cost. The
constraints ensure that candidate solutions are in the feasible region. They are composed of a series of equations
defined by decision variables which are unknown variables that are manipulated in the attempt to optimize the objective
functions and input variables predefined input variables that are assumed to be known. Furthermore, the decision
variables have components that are directly and indirectly manipulated. This will be further discussed in
[[#sec:decision-variables]].

#+include: "tab/variables.org"

** Parameter Definitions
:PROPERTIES:
:CUSTOM_ID: sec:parameter-definitions
:END:
This section defines the input variables and decision variables used by the system. The input variables are the
parameters that are assumed to be known prior to optimizing the system. The decision variables are the values that the
SA algorithm has the freedom to manipulate. The values produced by the SA algorithm will be interpreted as a candidate
charging solution. This is further described in [[#sec:simulated-annealing]].

*** Input Variables
:PROPERTIES:
:CUSTOM_ID: sec:input-variables
:END:
The input values of any MILP system are defined prior to the solving of the system. They define initial conditions,
known state properties, etc. Roughly following the order in [[tab:variables]], each variable will be introduced.

$\Delta_i$ is the amount power required to complete the bus route after visit $i$. Because there is no route after the
last visit has no discharge due to a route. Let $\Jset_b \subset \Iset$ denote the set of visit indices for bus $b$, and
let $\Jset_b^f$ denote the final visit index for bus $b$. Furthermore, let the $\Isetfinal = \{ x \in \Isetfinal \subset
\Iset : \forall b \in \Bset, x \in \Jset_b^f \}$. Therefore, the last visit for each bus has no discharge due to a bus
route and can be written as $\Delta_{\Isetfinal} = 0$. The discharge for visit all visits $i \in \{\Iset \setminus
\Isetfinal\}$, is defined by $\Delta_i = \delta_i \cdot \rho_i$ where $\delta_i$ is the amount of energy consumed by the
bus per mile and $\rho_{\Isetfinal}$ is the route mileage after visit $i$.

As discussed before, since there is no route after the last visit $\rho_I = 0$. $\alpha_b$ is the initial SOC percentage
of bus $b$ at the beginning of the working day. The initial SOC for bus $b$ can be represented as

#+name: eq:batinit
#+begin_export latex
\begin{equation}
\label{eq:batinit}
  \eta_{i_0^b} = \alpha_b \cdot \kappa_b \text{,}
\end{equation}
#+end_export

where $\kappa_b$ is the battery capacity for bus $b$, $\eta_{\Isetinit}$, $\Isetinit = \{ x \in \Isetinit \subset
\Iset : \forall b \in \Bset, x \in \Jset_b^0 \}$, indicates the initial charge for bus $b$. $\eta_i$ will be further
discussed in [[#sec:decision-variables]]. $\epsilon_q$ is the cost for assigning a charger to queue $q$. This parameter is
utilized by the objective function and is further discussed in [[#sec:objective-function]]. $\xi_i$ represents the next
arrival index for bus $b_i$. In other words, given a set of bus visit IDs $\Jset_b = \{ 1,2,3,1\}$, using a starting
index of 1, $\xi_1 = 4$. $a_i$ and $e_i$ are the arrival and departure times of bus visit $i$ to the station,
respectively. $k$ represents the local iteration search for the SA algorithm. This is further discussed in
[[#sec:simulated-annealing]]. Lastly, $r_q$ represents the rate of charge for the charger in queue $q$. As will be discussed
in [[#sec:objective-function]], fast chargers and slow chargers relate to high and low costs, $\epsilon_q$, respectively.

*** Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:decision-variables
:END:
Decision variables are the defined by the optimizer and are therefore unknown prior to running the optimization
algorithm. In this case the optimizer is SA. Once SA has been run and each of the decision variables have been specified
and the fitness of the solution is defined by the objection functions outlined in [[#sec:objective-function]] are
determined. The variables will be broken into two sections: direct and indirect decision variables. Decision variables
that are direct are values that the system has direct control over and indirect variables are those that are influenced
by the direct.

**** Direct Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:direct-decision-variables
:END:
Decision variables that are direct are variables that can be immediately chosen by SA. The first two variables are $u_i$
and $d_i \; \forall i \in \Iset$. They represent the initial and final charging times. These values must remain within
range of the arrival time and departure time for visit $i$, $[a_i, e_i]$. The last direct decision variable is the queue
that bus visit $i$ can be placed in to charge, $v_i \in \Qset$.

**** Indirect Decision Variables
:PROPERTIES:
:CUSTOM_ID: sec:indirect-decision-variables
:END:
Indirect decision variables are variables that are dependent on direct decision variables. For example $\eta_i$ is the
initial charge for visit $i$. These variables are chained together per bus by using the bus identifier, $b$, and next
index, $\xi_i$. The initial charges must be chained so that the battery charge can be calculated per bus as it is
charged and discharged over each visit, $[u_i, d_i]$. $\phi_i$ is a boolean decision variable, $\phi_i \in \{0,1\}$,
that either enables or disables the charge penalty defined in [[#sec:objective-function]]. $\sigma_{ij}$ and $\psi_{ij}$ are
used to indicate whether a visit pair $(i, j)$ overlap the same space as show in [[fig:spacial-and-temporal-constr]]. These
variables will be further elaborated on in [[#sec:constraints]]. $p_{dem}$ is the demand cost of the overall charging
schedule. It is calculated after all the decision variables have been assigned. This is further described in
[[#sec:objective-function]].

** Objective Function
:PROPERTIES:
:CUSTOM_ID: sec:objective-function
:END:
The objective function is used to compare the fitness of different candidate solutions against one another. This
objective function takes in input and decision variables to calculate some value of measure. The calculated objective
function value can either be maximized or minimized. The desired option is dependent on the problem to be solved as well
as the formulation of said objective function. Let $J$ represent the objective function. The objective function for this
problem has four main considerations: charger assignment, consumption cost, demand cost, and sufficient charge.

Suppose the objective function is of the form $\text{min } J = \AC + \PC$. $\AC$ is the assignment cost, and $\PC$ is
the power usage cost. The assignment cost represents the costs of assigning a bus to a particular queue as well as the
chosen charging period, $[u_i, d_i]$, as shown in [[eq:ac]]. $v_i \in q$ is the charger index, $u_i$ is the initial
charge time, $d_i$ is the detach time for visit $i$, $\phi_i$ is a binary decision variable, $m$ is the minimum charge
percentage allowed, $\kappa_i$ is the battery capacity for visit $i$, and $\eta_i$ is the charge for $b_i$ when it
arrives for visit $i$.

#+name: eq:ac
#+begin_export latex
\begin{equation}
\label{eq:ac}
\AC = \sum_{i=1}^I \Big(\epsilon_{v_i}(d_i - u_i) + \frac{1}{2} C \phi_i (\eta_i - m \kappa_i)^{2}\Big)
\end{equation}
#+end_export

The first term in the summation represents the calculation of the cost for assigning a bus to queue $q$ (i.e. cost of
using the charger multiplied by the usage time). The second term is the penalty function that is either enabled or
disabled by $\phi_i$. $\phi_i$ is enabled when the initial charge, $\eta_i$, is less than the allowed minimum charge,
$m\kappa_{b_i}$. This is further discussed in [[#sec:constraints]]. The form of the penalty function is the most common form
that they are found in \cite{Luenberger2008}. Note that the variables $\phi_i$ and $\eta_i$ are both decision
variables that are being multiplied together. This is called a bilinear term. Using a traditional MILP solver, this
would require linearization \cite{Rodriguez2013}; however, because SA handles nonlinearities easily these bilinear terms
will be ignored \cite{Radosavljevic2018-jc}.

The demand cost quantifies the amount of power being used over a given period and adjusts the cost accordingly. The
consumption cost calculates the total amount of power being consumed by the chargers. The consumption cost is merely the
summation of all the energy being used over all the active periods for each charger in the time horizon. It is written
as shown in [[eq:consumption-cost]]. $r_{v_i}$ is the active charger for visit $i$ and is multiplied by the time that the
charger will be utilized, $d_i - u_i$.

#+name: eq:consumption-cost
#+begin_export latex
\begin{equation}
\label{eq:consumption-cost}
  \sum_{i=1}^I \Big( r_{v_i}(d_i - u_i) \Big)
\end{equation}
#+end_export

The demand cost is calculated based on 15 minute increments (900 s). This cost is also referred to as the peak 15.
The average power used over an arbitrary 15 minute interval is represented by [[eq:p15]].

#+name: eq:p15
#+begin_export latex
\begin{equation}
\label{eq:p15}
p_{15}(t) = 1/900 \int_{t-15}^{t} p(\tau) d\tau
\end{equation}
#+end_export

Worst case must be assumed to always ensure enough power is supplied; therefore, the maximum value found is retained as
represented in [[eq:pmax]].

#+name: eq:pmax
#+begin_export latex
\begin{equation}
\label{eq:pmax}
p_{max}(t) = \text{max}_{\tau \in [0,t]}p_{15}(\tau)
\end{equation}
#+end_export

A fixed minimum cost is introduced before a specified threshold is exceeded. Let this fixed threshold be defined as
$p_{fix}$. In a similar manner as $p_{max}$, the maximum value is retained. Furthermore, let $s_r$ define the demand
rate which has the units of \(\frac{\$}{kW}\).

#+name: eq:pdem
#+begin_export latex
\begin{equation}
\label{eq:pdem}
p_{dem}(t) = \text{max}(p_{fix},p_{max}(t))s_r
\end{equation}
#+end_export

[[eq:pdem]], again, retains the largest $p_{dem}$ value with a starting fixed value of $p_{fix}$. To write the total power
demand at any discrete time, consider [[eq:discrete-power]]. Let $\omega_h$ be the discrete power demand and $h \in \{ 1, 2,
..., \Hd \} \subset \mathcal{Z}$ where $H = \frac{T}{900}$. For conciseness of notation we will abuse $t_h$ to denote
the time in discrete form (as opposed to $t$ being continuous) and let $\Hset = \{ 1, 2, ..., \Hd \}$. Let $\iota_h$ be
a binary decision variable that is enabled if charger $v_i \in \Qset$ is enabled in the time frame $[t_{h-1}, t_h]$,
where $t_h = 900 \cdot h$. Let the power usage of charger $v_i$ be denoted as $r_{v_i}$.

#+name: eq:discrete-power
#+begin_export latex
\begin{equation}
\label{eq:discrete-power}
  \omega_h = \sum_i^I \iota_h \cdot r_{v_i}
\end{equation}
#+end_export

The average power can be rewritten as $p_{15}^h = \omega_h$, $p_{dem}$ can be rewritten as $p_{dem}^h = \text{max}_{h \in
\Hset} (p_{15}^{h})$, and finally $p_d^h$ can be written as [[eq:pd-dis]].

#+name: eq:pd-dis
#+begin_export latex
\begin{equation}
\label{eq:pd-dis}
  p_d^h = \text{max}_{h \in \Hset}(p_{fix}, p_{max})s_d
\end{equation}
#+end_export

To write the power cost, [[eq:consumption-cost]] and [[eq:pd-dis]] are superimposed to create [[eq:pc]].

#+name: eq:pc
#+begin_export latex
\begin{equation}
\label{eq:pc}
\PC = p_d^h + \sum_{i=1}^I \Big( r[v_i](d_i - u_i) \Big)
\end{equation}
#+end_export

** Constraints
:PROPERTIES:
:CUSTOM_ID: sec:constraints
:END:
Now that a method of calculating the fitness of a schedule has been established, a method for determining the
feasibility of a schedule must be established. Feasible schedules require that the schedule maintain a certain list of
properties. These properties are enforced by a set of constraints derived from the MILP PAP. The constraints must ensure
no overlap temporally or spatially, receives enough charge to complete route after each visit $i$, bus visit $i$ cannot
be over charged, each visit, $i$, departs on time. The aforementioned constraints are shown in [[eq:constraints]].

#+name: eq:constraints
#+begin_export latex
\input{eq/constraints.tex}
#+end_export

# Org mode is a little silly and does not take normal referencing syntax. This note is for future reference.
Where the valid queue \ref{seq:c0} - \ref{seq:c4} define the spatial and temporal constraints of the system. These
constraints enforce that the buses are placed in such a way that only one bus is allowed at a charger at any given time.
Particularly \ref{seq:c0} determines if the initial charge time of visit $i$ is after the final charge time of visit
$j$. Similarly, \ref{seq:c1} determines if visit $i$ or visit $j$ are scheduled to be on the same queue. \ref{seq:c2}
describes whether one of the visits come after the other temporally while \ref{seq:c3} describes if the chargers are
placed in different queues. \ref{seq:c4} pulls all the previous constraints together and verifies that at least one of
the conditions are true for each visit pair $(i,j)$. The concept of the temporal and spatial constraints can be
visualized by [[fig:spacial-and-temporal-constr]]. The y-axis represents the possible queues for a bus visit to be placed
into and the x-axis represents the time that can be reserved for each visit. The shaded rectangles represent time that
has been scheduled for each bus visit. The set of constraints \ref{seq:c0} - \ref{seq:c4} aim to ensure that these
shaded rectangles never overlap. \ref{seq:c5} calculates the discharge for the route after visit $i$. \ref{seq:c6}
calculates the initial charge for the next visit for bus $b_i$. \ref{seq:c7} ensures that the bus is not being over
charged. \ref{seq:c8} and \ref{seq:c9} are used to enable and disable the penalty method in [[eq:ac]]. This is done by
checking if the initial charge for visit $i$ is greater than or equal to the minimum allowed charge. \ref{seq:c10}
ensures the continuity of the times (i.e. the arrival time is less than the initial charge which is less than the detach
time which is less than the time the bus exits the station and all must be less than the time horizon).

#+name: fig:spacial-and-temporal-constr
#+begin_export latex
\input{img/spacial-temporal-constr.tex}
#+end_export

* Simulated Annealing
:PROPERTIES:
:CUSTOM_ID: sec:simulated-annealing
:END:
SA is a local search (exploitation oriented) single-solution based (as compared to population based) metaheuristic
approach in which its main advantage is its simplicity both theoretically and in its implementation as well its inherit
ability to overcome nonlinearities \cite{Gendreau2018-pw, Radosavljevic2018-jc}. This model is named after its
analogized process where a crystalline solid is heated then allowed to cool very slowly until it achieves its most
regular possible crystal lattice configuration \cite{Henderson}. There are five key components to SA: initial
temperature, cooling schedule (temperature function), generation mechanism, acceptance criteria, local search iteration
count (temperature change counter) \cite{Keller_2019}.

** Cooling Equation (Experimental)
:PROPERTIES:
:CUSTOM_ID: cooling-equation-experimental
:END:
The initial temperature and cooling schedule are used to regulate the speed at which the solution attempts to converge
to the best known solution. When the temperature is high, SA encourages exploration. As it cools down (in accordance to
the cooling schedule), it begins to encourage local exploitation of the solution \cite{Rutenbar_1989, Henderson}. There
are three basic types of cooling equations as shown in [[fig:cool]] \cite{Keller_2019}. The different types merely dictate
the rate at which we begin disallowing exploration. A linear cooling schedule is defined by [[eq:cool0]].

#+name: eq:cool0
#+begin_export latex
\begin{equation}
\label{eq:cool0}
\Tau[n] = \Tau[n-1] -\Delta_0
\end{equation}
#+end_export

with $\Tau[0] = \Tau_0$ and $\Delta_0 = 1/2\; C^\circ$ in [[fig:cool]]. A geometric cooling schedule is mostly used
in practice \cite{Keller_2019}. It is defined by [[eq:cool1]].

#+name: eq:cool1
#+begin_export latex
\begin{equation}
\label{eq:cool1}
\Tau[n] = \alpha \Tau[n-1]
\end{equation}
#+end_export

where $\alpha = 0.995$ in [[fig:cool]]. An Exponential cooling schedule is defined by the difference equation is
define as [[eq:cool2]].

#+name: eq:cool2
#+begin_export latex
\begin{equation}
\label{eq:cool2}
\Tau[n] = e^{\beta}\Tau[n-1]
\end{equation}
#+end_export

where $\beta = 0.01$ in [[fig:cool]]. The initial temperature, $T_0$, in the case of [[fig:cool]], is
set to $500^\circ\; C$ and each schedule's final temperature is $1\; C^\circ$.

#+name: fig:cool
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
#+caption: Cooling equations \label{fig:cool}
[[file:img/cool-func.jpg]]

** Acceptance Criteria
:PROPERTIES:
:CUSTOM_ID: sec:acceptance
:END:
Acceptance criteria describes the method to accept or reject a given candidate solution. In SA, if a new candidate
solution is more fit than the currently stored solution it is always accepted as the new solution. However, within SA,
worse candidate solutions may be accepted as the new solution. The probability of accepting the candidate solution is
described by the function $\exp(\frac{J(x) - J(x')}{\Tau})$ where $J(\cdot)$ is the objective functions described in
[[#sec:objective-function]]. The probability of acceptance is a function of the cooling equation just described and
difference of the current solution and a new candidate solution. Let $\Delta E \equiv J(x) - J(x')$ where $x$ is the
current solution and $x'$ is the new candidate solution. The probability of acceptance of $x'$ is defined by
[[eq:candaccept]] \cite{Keller_2019}.

#+name: eq:candaccept
#+begin_export latex
\begin{equation}
\label{eq:candaccept}
f(x,x',T) =
\begin{cases}
  1                 & \Delta E > 0 \\
  e^{- \frac{\Delta E}{T}} & \text{otherwise}
\end{cases}
\end{equation}
#+end_export

** Generation Mechanisms
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
Generation mechanisms in SA are used to generate random solutions to propose to the optimizer, these are known as
candidate solutions. In the case of the problem statement made in [[#sec:problem-description]], five generation mechanism
shall be used: new visit, slide visit, new charger, remove, new window. The purpose of each of these generators is to
assign new visits to a charger, adjust a bus visits initial and final charge time within the same time frame/queue,
remove a bus from a charger, and place a bus visit into a new time slot/queue. Each generator will be discussed in more
detail in [[#sec:generators]].

These generator mechanisms will in turn be utilized by three wrapper functions. The purpose of the route generation to
create a set of bus route data to feed to the SA algorithm. Although, strictly speaking, is not a part of the SA
algorithm. It is vital in specifying the initial conditions and "setting the stage" for the SA algorithm to solve. The
schedule generation is to used create candidate solutions for SA to compare with other solutions, and the perturb
schedule generator is used to take a candidate solution and alter it slightly in an attempt to fall into a global/local
minimum.

*** Generator Input/Output
:PROPERTIES:
:CUSTOM_ID: sec:generator-input-output
:END:
This section discusses in detail the expected inputs and output of each generator. It is important to discuss these
parameters in order to have an understanding of the generating algorithms derived. The input consists of the bus visit
index of interest, information about the current state of arrivals, $\I$, and the current state of the chargers'
availability, $\C$. The output of each generator affects the tuple of decision variables $(v_i, u_i, d_i) \subset \I$.

**** Generator Input
Each generator has the tuple input of ($i, \I, \C$) where $i$ is the visit index, $\I_i$ is the tuple $\visit$
([[#sec:problem-description]]), that describes the set of visits generated by the route generation algorithm
([[#sec:route-gen]]), and $\C$ is the set that describes the availability for all chargers $q \in \mathcal{Q}$. In other
words, $\C$ defines the set of times when the chargers are not being utilized or are "inactive".

To derive $\C$, consider its inverse, $\C'$, which is the set of "active" time periods for each charger, $\C' = \bigcup
\{\C_q' : q \in \mathcal{Q}\}$ where $\C_q' \subset \C'$ describes the active times for chagrer $q$. Focusing on an
individual charger, consider $\C_q'$ before a schedule has been imposed upon it, $\C_q' \in \varnothing$. In other
words, no buses have been assigned to be charged over the time period of $[u_i, d_i]$. After the scheduling process is
complete, $\C_q'$ will have a set of active periods of the form $\C_q' \in \{[u_j, d_j]: j \in \mathbb{J}\}$ where
$\mathbb{J} \subset \mathcal{I}$. For $\C_q'$ to be of value, its compliment is to be found, $\C_q$.

To determine the inverse of $\C_q'$, begin by noting $\C_q' \bigcap \{[u_j, d_j] : j \in \mathbb{J}\} = \varnothing$,
in other words is said to be disjoint \cite{NaiveHalmos}. The inverse of a disjoint set can be found by the De Morgan
Law as shown in [[eq:demorgan]]. Using [[eq:demorgan]], the set of inactive periods can be written as $\C_q \equiv \bigcup
\{[u_j, d_j]': j \in \mathbb{J}\}$. Let $\Sol$ denote the tuple $\Sol \equiv (i, \I, \C)$.

#+name: eq:demorgan
#+begin_export latex
\begin{equation}
\label{eq:demorgan}
(A \cap B)' = A' \cup B'
\end{equation}
#+end_export

**** Generator Output
The output, $x_i' \equiv (v_i, u_i, d_i) \subset \I_i$ defines tuple of the chosen queue, initial charge time, and
detach time from the generator, $(v_i, u_i, d_i)$. The nature of SA implies that the generators have a sense of
randomness. Because of that, some of the generators may have multiple choices for what $x_i'$ may be. Let the set of
candidates for the output be defined as $x_i' \in X_i'$.

*** Generators
:PROPERTIES:
:CUSTOM_ID: sec:generators
:END:
This section describes and outlines the algorithm pool for the different generator types that are utilized in the
wrapper functions. Note that to satisfy constraints, $B$ extra idle queues that provide no power to the bus. Because of
this, the set of queues is fully defined as $q \in \{1,..., Q, Q+1,..., Q+b\}$ where $Q$ is the total amount of chargers
and $b$ is the bus ID. The use case for this is for when a bus is not to be placed on a charger, it will be placed in
the queue, $v_i \in \{Q+1,..., Q+b\}$, which will satisfy the constraints above while allowing the bus to be "set aside"
while others charge.

**** New visit
:PROPERTIES:
:CUSTOM_ID: new-visit
:END:
The new visit generator describes the process of moving bus $b$ from the idle queue, $v_i \in \{Q+1,..., Q+b\}$ to a
valid charging queue, $v_i \in \{1,..., Q\}$. Lines 2 through 4 extract the index, arrival time, and departure time for
visit $i$. Note that in subsequent algorithms, these lines will be omitted. Line 5 initializes the set of solutions to
the empty set. Line 6 loops through each charger availability set and line 7 loops thorough each of the available
ranges, denoted as $L$ and $U$ for lower and upper free time. Line 8 checks if the range $[a_i, e_i] \subset [L, U]$,
and lines 9 and 10 add it to the set of candidates. Line 14 chooses picks a candidate solution, $x_i' \subset X_i'$, with a
discrete uniform distribution which is denoted by $\U_{\{\cdot\}}$.

#+name: alg:new-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-visit}
\caption{New visit algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Visit}
    \KwIn{($\Sol$)}
    \KwOut{$x_i'$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{findFreeTime}{findFreeTime}

    \Begin
    {
        $i    \leftarrow \{i: i \in \Sol \}$ \tcc*{The index of the visit $i$}
        $a_i  \leftarrow \{ a_i \in \I_i : \I_i \in \I \subset \Sol \}$ \tcc*{Get the arrival time for visit $i$}
        $e_i  \leftarrow \{ e_i \in \I_i : \I_i \in \I \subset \Sol \}$ \tcc*{Get the departure time for visit $i$}
        $X_i' \leftarrow \varnothing$ \tcc*{Begin with the empty set}

        \ForEach (\tcc*[f]{For set of availabile times for charger $q$}) {$\C_q \in \C$}
        {
            \ForEach (\tcc*[f]{For each inactive region in $\C_q$}) {$C \in \C_q$}
            {
                \If(\tcc*[f]{If there is time available in $C$}){\findFreeTime{C, ($a_i, e_i$)} $\not\in \varnothing$}
                {
                    $x_i' \rightarrow$ \findFreeTime{C, ($a_i, e_i$)} \tcc*{Assign $x_i'$ to the found reigion}
                    $X_i' \cup x_i'$ \tcc*{Add $x_i'$ to the set of candidates}
                }
            }
        }
        \Return{$\U_{X_i'}$} \tcc*[f]{Return a random candidate}
    }
\end{algorithm}
#+end_export

The algorithm to find free time is defined in Algorithm [[alg:find-free-time]]. $L$ and $U$ are the lower and upper bound of
the time between scheduled times. The possible use cases are depicted in [[fig:find-free]]. In each case depicted by
[[fig:find-free]], the red line shows the arrival and departure time for an arbitrary bus visit, $i$. The blue lines indicate
reigons in which charger $q$ is active. $C \in \C_q \subset \C$ represents one of the regions between the blue lines, $[L, U]$
which stand for the lower and upper portions of the regions, respectively. The output of [[alg:find-free-time]] is a range for
which the bus may be charged and the empty set if it cannet. As an example, consider a bus that is in the process of being
scheduled and it encounters a situation similar to \autoref{subfig:egu}. That is, the only scheduling constraint is that the
arrival time is before charger $q$ is available to charge the bus. Therefore the bus must wait intil $L$ before changer $q$ may
charge it. Furthermore, the range that $u_i$ must be selected from is $[L,e]$.

#+name: fig:find-free
#+begin_export latex
\input{img/find-free.tex}
#+end_export

#+name: alg:find-free-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:find-free-time}
\caption{Find free time algorithm searches and returns the available time frames}
    \LinesNumbered
    \TitleOfAlgo{Find Free Time}
    \KwIn{$(L,U,a,e)$}
    \KwOut{$(u,d)$}

    \Begin
    {
        \If(\tcc*[f]{If $L < a < e < U]$ (\autoref{subfig:sandwich})}){$L \leq a$ and $U \geq e$}
        {
                u $\leftarrow$ $\U_{[a,e]}$\;
                d $\leftarrow$ $\U_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a < L < e < U$ (\autoref{subfig:all})}){$L > a$ and $U \geq e$}
        {
                u $\leftarrow$ $\U_{[L,e]}$\;
                d $\leftarrow$ $\U_{[u,e]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $L < a < U < e$ (\autoref{subfig:egu})}){$L \leq a$ and $U < e$}
        {
                u $\leftarrow$ $\U_{[a,U]}$\;
                d $\leftarrow$ $\U_{[u,U]}$\;
        }
        \ElseIf(\tcc*[f]{Else if $a \leq u \leq d \leq L$ or $U \leq a \leq d \leq e$ (\autoref{subfig:invertsandwhich})}){$L > a$ and $U < e$}
        {
                u $\leftarrow$ $\U_{[a,L], [U,e]}$\;
                d $\leftarrow$ $\U_{[u,L], [u,e]}$\;
        }
        \Else(\tcc*[f]{Otherwise the bus cannot be scheduled in this time frame (\autoref{subfig:invalid})})
        {
                u $\leftarrow$ $\varnothing$\;
                d $\leftarrow$ $\varnothing$\;
        }

        \Return{(u,d)}
    }
\end{algorithm}
#+end_export

**** Slide visit
:PROPERTIES:
:CUSTOM_ID: slide-visit
:END:
Slide visit is used for buses that have already been scheduled. Because of the constraint \ref{seq:c10} there may be
some room to move $u_i$ and $d_i$ within the window $[a_i, e_i]$. Two new values, $u_i$ and $d_i$ are selected with a
uniform distribution to satisfy the constraint $a_i \leq u_i \leq d_i \leq e_i$. Line 1 initializes the candidate set to
be the original charge time frame. Line 3 loops through each opening for charger $q$, and line 4 checks if a new time
frame $[u_i, d_i]$ is able to be scheduled. Lines 5 and 6 add that time frame to the set of candidates. Line 9 returns a
candidate with a discrete uniform distribution.

#+name: alg:slide-visit
#+begin_export latex
\begin{algorithm}[H]
\label{alg:slide-visit}
\caption{Slide Visit Algorithm}
    \LinesNumbered
    \TitleOfAlgo{Slide Visit}
    \KwIn{$\Sol$}
    \KwOut{$x_i'$}

    \Begin
    {
        $X_i' \leftarrow \varnothing$ \tcc*{Begin with the empty set}

        \ForEach (\tcc*[f]{For each inactive region in $\C_q$ where $q = v_i$}) {$C \in \C_q$}
        {
            \If(\tcc*[f]{If there is time available in $C$}){\findFreeTime{C, ($a_i, e_i$)} $\not\in \varnothing$}
            {
                $x_i' \rightarrow$ \findFreeTime{C, ($a_i, e_i$)} \tcc*{Assign $x_i'$ to the found reigion}
                $X_i' \cup x_i'$ \tcc*{Add $x_i'$ to the set of candidates}
            }
        }

        \Return{$\U_{X_i'}$} \tcc*[f]{Return a random candidate}
    }
\end{algorithm}
#+end_export

**** New charger
:PROPERTIES:
:CUSTOM_ID: new-charger
:END:
The new charger generator takes a visit $\I_i$ and changes the charger it is on while maintianing the same charge time,
$[u_i, d_i]$. Similarly to [[alg:new-visit]], the new candidate, $x_i'$, must be checked before being added to the set
$X_i'$. Line 2 initializes the candidates to the empty set. Line 3 and 4 loop though each charger availability set and
each available range for charger $q$.

#+name: alg:new-charger
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-charger}
\caption{New Charger Algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Charger}
    \KwIn{$\Sol$}
    \KwOut{$x_i'$}

    \Begin
    {
        $X_i' \leftarrow \varnothing$ \tcc*{Begin with the empty set}

        \ForEach (\tcc*[f]{For set of availabile times for charger $q$}) {$\C_q \in \C$}
        {
            \ForEach (\tcc*[f]{For each inactive region in $\C_q$}) {$C \in \C_q$}
            {
                \If (\tcc*[f]{If the charge time is within the region $[L,U]$}) {$L \leq u$ \And $U \geq e$}
                {
                    $X_i' \cup (q, u_i, d_i)$ \tcc*{Append the candidate to the set}
                }
            }
        }

        \Return{$\U_{X_i'}$} \tcc*[f]{Return a random candidate}
    }
\end{algorithm}
#+end_export

**** Remove
:PROPERTIES:
:CUSTOM_ID: sec:remove
:END:
The remove generator simply removes a bus from a charger queue and places it in its idle queue, \(v_i \in
\{Q,...,Q+B\}\).

#+name:alg:remove
#+begin_export latex
\begin{algorithm}[H]
\label{alg:remove}
\caption{Remove algorithm}
    \LinesNumbered
    \TitleOfAlgo{Remove}
    \KwIn{$\Sol$}
    \KwOut{$x_i'$}

    \Begin
    {
       \Return{$(Q+b,a_i,e_i)$}
    }
\end{algorithm}
#+end_export

**** New Window
:PROPERTIES:
:CUSTOM_ID: sec:new-visit
:END:
New window is a combination of the remove and then new visit generators ([[#sec:remove]] and [[#sec:new-visit]]). By this it is
meant that current scheduled tuple $(v_i, u_i, d_i)$ is removed and added back in as if it were a new visit.

#+name: alg:new-window
#+begin_export latex
\begin{algorithm}[H]
\label{alg:new-window}
\caption{New window algorithm}
    \LinesNumbered
    \TitleOfAlgo{New Window}
    \KwIn{$\Sol$}
    \KwOut{$x_i'$}

    \Begin
    {
        \SetKwFunction{NewVisit}{NewVisit}
        \SetKwFunction{Remove}{Remove}

        $x_i' \leftarrow$ \Remove{$v,u,d$} \tcc*{Remove visit $i$ from its charger}
        $x_i' \leftarrow$ \NewVisit{$x_i'$} \tcc*{Add visit $i$ back in randomly}

        \Return{$(v,u,d)$}
    }
\end{algorithm}
#+end_export

*** Generator Wrappers
:PROPERTIES:
:CUSTOM_ID: generator-wrappers
:END:
This section covers the algorithms utilized to select and execute different generation processes for the SA process. The
generator wrappers are the method immediately called by SA. Each wrapper utilizes the generators previously described
and returns either metadata about the bus routes or a new valid charger schedule.

**** Route Generation
:PROPERTIES:
:CUSTOM_ID: sec:route-gen
:END:
The objective of route generation is to create a set of metadata about bus routes given the information in
[[fig:routeyaml]]. Specifically, the objective is to generate the input variables in $\I$ for $I$ visits with $B$ buses.
Each visit will have an initial charge (specified for first visit only), arrival time, departure and time. In other
words, $y_i \equiv (a_i, e_i) \subset \I \forall i in \Iset$ and each bus will be initialed with the SOC defined by
[[eq:batinit]].

In essence the logic is as follows: Generate $B$ random numbers that add up to $I$ visits (with a minimum amount of
visits set for each bus). For each bus and for each visit, set a departure time that is between the range [min_rest,
max_rest] ([[fig:routeyaml]]), set the next arrival time to be $j \cdot \frac{T}{\text{J}}$ where $j$ is the $j^{th}$ visit
for bus $b$ and $J$ is the total number of visits for bus $b$. Finally, calculate the amount of discharge from the
previous arrival to the next departure time as defined by [[eq:batinit]].

The metadata in [[fig:routeyaml]] will be denoted by $\M$ visually represents the YAML file used. This data contains all the
parameters required to create a set of bus routes. Each of the cells will now be described from left to right, top to
bottom. =time_horizon= represents the amount of time that the routes will be running for in hours. =schedule= contains
the parameters that directly affect the generated set of routes. Some of the parameters in the YAML have already been
defined in this paper, but go under a different name in the file. These parameters are: =num_bus= $\equiv B$,
=num_visit= $\equiv I$, and =bat_capacity= $\equiv \kappa$. =max_charge= and =min_charge= represent the maximum and
minimum percentages that the buses may be charged to. =max_rest= and =min_rest= represent the maximum and minimum times
that buses may remain at the station, and =max_route= and =min_route= represent the maximum and minimum lengths that bus
routes may be.

#+name: fig:routeyaml
#+caption: Route YAML file with example data
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/route_yaml.png]]

#+name: alg:route-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:route-generation}
\caption{Route generation algorithm}
    \LinesNumbered
    \TitleOfAlgo{RouteGeneration}
    \KwIn{$\M$}
    \KwOut{$\I$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{DepartureTime}{DepartureTime}
    \SetKwFunction{ArrivalTimeNew}{ArrivalTimeNew}
    \SetKwFunction{Discharge}{Discharge}
    \SetKwFunction{SortByArrival}{SortByArrival}
    \SetKwFunction{Feasible}{Feasible}

    \Begin
    {
        \While{\Not schedule-created}
        {
            arrival-new $\leftarrow$ 0.0\;
            arrival-old $\leftarrow$ 0.0\;
            departure-time $\leftarrow$ 0.0\;
            schedule-created $\leftarrow$ false\;

            \ForEach{b $\in$ B}
            {
                \ForEach{n $\in\; J_b$}
                {
                    arrival-old $\leftarrow$ arrival-new\;

                    \If{j = $J_b$}{final-visit = true\;}
                    \Else{final-visit = false\;}

                    departure-time $\leftarrow$ \DepartureTime{arrival-old, final-visit}\;
                    arrival-new $\leftarrow$ current-visit*$\frac{T}{J_b}$\;
                    discharge $\leftarrow$ discharge-rate*(next-arrival, depart-time)    \;
                    \Union{$\I$, (arrival-old, departure-time, discharge)}\;
                }
            }

            schedule-created $\leftarrow$ \Feasible{$\I$}\;
            \SortByArrival{$\I$}\;
        }
        \Return{$\I$}
    }
\end{algorithm}
#+end_export

The =Departure= algorithm is shown in Algorithm [[alg:departure-time]], and the =Feasible= method is used to determine if
the generated schedule is valid (conditions covered in [[#sec:constraints]]). This is done to generate a schedule that is in
the solution space.

#+name: alg:departure-time
#+begin_export latex
\begin{algorithm}[H]
\label{alg:departure-time}
\caption{Departure time algorithm}
    \LinesNumbered
    \TitleOfAlgo{DepartureTime}
    \KwIn{(arrival-old, final-visit)}
    \KwOut{depart}

    \Begin
    {
        \If{final-visit}
        {
            depart $\leftarrow$ T\;
        }
        \Else
        {
            depart $\leftarrow$ arrival-old + $\U_{[\text{min-rest},\text{max-rest}]}$\;
        }

        \Return{depart}
    }
\end{algorithm}
#+end_export

**** Schedule Generation
:PROPERTIES:
:CUSTOM_ID: schedule-generation
:END:
The objective of this generator is to generate a candidate solution to the given schedule. To generate a candidate
solution, the generator is given $\I$, a bus is picked at random, $b \in \Bset$, then a random visit is picked. The new
visit generator ([[alg:new-visit]]) is then utilized. This process is repeated for each visit. This algorithm is summarized
in [[alg:schedule-generation]].

#+name: alg:schedule-generation
#+begin_export latex
\begin{algorithm}[H]
\label{alg:schedule-generation}
\caption{Schedule generation algorithm}
    \LinesNumbered
    \TitleOfAlgo{ScheduleGeneration}
    \KwIn{$\I$}
    \KwOut{$\I$}

    \SetKwFunction{Union}{Union}
    \SetKwFunction{NewVisit}{NewVisit}

    \Begin
    {
        $\I \leftarrow\; \varnothing$\;
        \For {i in I}
        {
            $b \leftarrow\; \U_{\Bset}$\;
            $i\leftarrow\; \U_{\Iset}$\;
            \NewVisit{(visit.a, visit.e)}
        }
            \Return{$\I$}
    }
\end{algorithm}
#+end_export

**** Perturb Schedule
:PROPERTIES:
:CUSTOM_ID: tweak-schedule
:END:
As described in SA, local searches are also employed to try and exploit a given solution \cite{Radosavljevic2018-jc}.
The method that will be employed to exploit the given solution is as follows: pick a bus, pick a visit, pick a
generator. The algorithm is outlined in Algorithm [[alg:perturb-schedule]].

#+name: alg:perturb-schedule
#+begin_export latex
\begin{algorithm}[H]
\label{alg:perturb-schedule}
\caption{Perturb schedule algorithm}
    \LinesNumbered
    \TitleOfAlgo{PerturbSchedule}
    \KwIn{$\I$}
    \KwOut{$\I$}

    \SetKwFunction{GeneratorCallback}{GeneratorCallback}

    \Begin
    {
        \For {i in I}
        {
            visit $\leftarrow\; \U_{\Iset}$\;
            generator $\leftarrow\; \U_{[0,generator-count]}$\;
            $\I$ $\leftarrow$ \GeneratorCallback[generator]{(visit, route-data, charger-data)}\;
        }

        \Return{$\I$}
    }
\end{algorithm}
#+end_export

* Optimization Algorithm
:PROPERTIES:
:CUSTOM_ID: optimization-algorithm
:END:
This final section combines the generation algorithms and the optimization problem into a single algorithm. The
objective is to outline the SA process from start to finish. Algorithm [[alg:route-generation]] generates a set of bus
routes utilizing the route metadata in [[fig:routeyaml]]. The initial temperature and cooling schedule will be selected
prior to execution and passed into the SA optimization algorithm. A new candidate solution will be generated. The
candidate solution will be checked if it is feasible by using the equations from [[#sec:constraints]]. For each step in the
cooling schedule will have $K$ iterations to attempt to find a local maxima. Each perturbation to the system is then
compared to the current candidate solution. If the new candidate solution is better it is kept; however, if the
candidate solution is worse, the solution may still be kept with a calculated probability as described in
[[#sec:acceptance]]. This process is summarized in Algorithm [[alg:sa-pap]].

#+name: alg:sa-pap
#+begin_export latex
\begin{algorithm}[H]
\label{alg:sa-pap}
\caption{Simulated annealing approach to the position allocation problem}
    \LinesNumbered
    \TitleOfAlgo{SA PAP}
    \KwIn{Bus route metadata: (file-path)}
    \KwOut{Optimal charging $\I$: ($\I$)}

    \SetKwFunction{InitTemp}{InitTemp}
    \SetKwFunction{GetCoolingEquation}{GetCoolingEquation}
    \SetKwFunction{InSolutionSpace}{InSolutionSpace}
    \SetKwFunction{LoadYaml}{LoadYaml}
    \SetKwFunction{RouteGeneration}{RouteGeneration}
    \SetKwFunction{J}{J}
    \SetKwFunction{ScheduleGeneration}{ScheduleGeneration}
    \SetKwFunction{PerturbSchedule}{PerturbSchedule}

    \Begin
    {
        $\Tau_0\; \leftarrow$ \InitTemp{}\;
        $\Tau_{$\I$}\; \leftarrow$ \GetCoolingEquation{}\;

        route-metadata $\leftarrow$ \LoadYaml{file-path}\;
        routes $\leftarrow$ \RouteGeneration{route-metadata}\;

        best-solution $\leftarrow v \in$ \ScheduleGeneration{routes}\;

        \ForEach{$\Tau \in \Tau_{$\I$}(\Tau_0)$}
        {
            candidate-solution $\leftarrow$ \ScheduleGeneration{routes}\;

            \If{\InSolutionSpace{candidate-solution}}
            {
              \ForEach{$k \in K$}
              {
                del-sol $\leftarrow$ \J{candidate-solution} - \J{best-solution}\;

                \If{del-sol $\leq$ 0}
                {
                   best-solution $\leftarrow$ candidate-solution\;
                }
                \ElseIf{del-sol $\geq$ 0}
                {
                    best-solution $\leftarrow$ candidate-solution with probability $\exp$(del-sol$\tau_k$)\;
                }

                $\I$ $\leftarrow$ \PerturbSchedule{schedule}\;
            } % If
          }   % ForEach
        }     % If
    }
\end{algorithm}
#+end_export

\bibliographystyle{plain}
\bibliography{main}

#+name: fig:route
#+caption: Route generation state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/route_generation.png]]

#+name: fig:schedule
#+caption: Charge solution state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.5\textwidth
[[file:img/charge_solution.png]]

#+name: fig:perturb
#+caption: Solution perturb state diagram
#+ATTR_ORG: :width 200
#+ATTR_LATEX: :width 0.2\textwidth
[[file:img/charge_perturb.png]]


#  LocalWords:  SA
